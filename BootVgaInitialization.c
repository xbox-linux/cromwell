/*
 * video-related stuff
 * 2002-12-04  andy@warmcat.com  Video now working :-)
 */

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#include "boot.h"

BYTE bFinalConexantA8, bFinalConexantAA, bFinalConexantAC;

void * memset(void *dest, int data,  size_t size);


// these are some kind of calibration table
// used to assess results of initial sampling/averaging action

const BYTE baVideoAvgCalibration[]={  // unknown function, first few bytes must be present for video to come up with ms bootloader

	// b7 clear on all bytes

	32,
	78,
	78,  //
	62,
	86,  // first comparison
	67,
	93,
	74,
	100,
	80,
	106,
	85

};

const BYTE baVideoInitTable2Standard[] = {

	// 2 x 5 x 19-byte structs follow, all seem to follow 4, 4, 4, 4, 3 structure
	// only low 4 bits used on each byte

	// first set of 5 structs have 1 in first byte of triplet

9,9,14,8,  // always ... 14, 8
15,15,15,15,  // all 0F s appears only in second DWORD of struct, always same
9,9,14,8,  // always ... 14, 8
9,9,14,8,  // always ... 14, 8
1,0,0, // always ... 0

//0x13
9,9,14,8,
15,15,15,15,
9,9,14,8,
9,9,14,8,
1,1,0,

//0x26
9,9,14,8,
15,15,15,15,
9,9,14,8,
9,9,14,8,
1,2,0,

//0x39
10,11,14,8,
15,15,15,15,
10,11,14,8,
10,11,14,8,
1,2,0,

//0x4c
11,14,14,8,
15,15,15,15,
11,14,14,8,
11,14,14,8,
1,3,0

};

const BYTE baVideoInitTable2Alternate[] = {
	// second set of structs have 0 in first byte of triplet
	// these are chosen if b17b16 of a DWORD read of MMIO+101000h are not 11

9,9,14,8,
15,15,15,15,
9,9,14,8,
9,9,14,8,
0,0,0,

9,9,14,8,
15,15,15,15,
9,9,14,8,
9,9,14,8,
0,1,0,

9,9,14,8,
15,15,15,15,
9,9,14,8,
9,9,14,8,
0,2,0,

10,11,14,8,
15,15,15,15,
10,11,14,8,
10,11,14,8,
0,2,0,

11,14,14,8,
15,15,15,15,
11,14,14,8,
11,14,14,8,
0,3,0
};


const BYTE baGraInit[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0f, 0xff };
const BYTE baSequencerInit[] = { 0x03, 0x21, 0x0f, 0x00, 0x06 };
const BYTE baAttrInit[] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x01, 0x4a, 0x0f, 0x00, 0x00
 };
const DWORD dwaVideoUnlockIoOfssets[] = {
	0xfd00122c, 0xfd00123c, 0xfd001230, 0xfd001240, 0xfd001234, 0xfd001244, 0xfd001238, 0xfd001248, 0xfd001214
};


const DWORD dwaKernelVideoLookupTable[] = {

	0x6808C0, 0x6808C4, 0x680630,	0x680680, 0x680684, 0x680688,	0x68068C, 0x680690,

	// mode 1
	0x0, 0x40801080, 0x2,	0x0C6ED0, 0x20D, 0x9B,  0x26C, 0x0,
	// mode 2
	0x0, 0x40801080, 0x2,	0x0DF05C, 0x20D, 0x0AE, 0x2B8, 0x0,
	//mode 3
	0x0, 0x40801080, 0x2,	0x0F387C, 0x271, 0x0BE,	0x2F8, 0x0,
	//mode 4
	0x0, 0x40801080, 0x2, 0x10D2A4, 0x271, 0x0D2,	0x348, 0x0,
	// mode 5
	0x0, 0x40801080, 0x2, 0x0F07A8, 0x271, 0x9D,  0x276, 0x0,
	// mode 6
	0x0, 0x40801080, 0x2, 0x10E62C, 0x271, 0x0B1,	0x2C4, 0x0,
	// mode 7
	0x0, 0x40801080, 0x2, 0x35A,    0x1,   0x0AB,	0x2AE, 0x1,
	// mode 8
	0x0, 0x40801080, 0x2,	0x30A,	  0x1,   0x0AB, 0x2AE, 0x1,
	// mode 9, taken from 640x576 after nvtv moved to 800x600
	0x0, 0x40801080, 0x2, 0x30a, 0x01, 0xab,	0x2ae, 0x01,

};


// memory mapped IO

void vgaout(unsigned int port, unsigned char reg, unsigned char data) {
	*((volatile unsigned char*)(port)) = reg;
	*((volatile unsigned char*)(port+1)) = data;
}

#define voutb(nAds, b) {	*((volatile BYTE*)((nAds))) = (b); }
#define voutw(nAds, w) {	*((volatile WORD*)((nAds))) = (w); }
#define voutl(nAds, dw) {	*((volatile DWORD*)((nAds))) = (dw); }

#define vinb(nAds) (*((volatile BYTE*)((nAds))))
#define vinl(nAds) (*((volatile DWORD*)((nAds))))



void GetTickCount(DWORD * pdw1, DWORD * pdw2)
{
	DWORD dw1, dw2;

	__asm__ __volatile__ (
		"rdtsc " : "=a" (dw1), "=d" (dw2)
	);
	*pdw1=dw1; *pdw2=dw2;
}

void BootVideoDelay(void)
{
	DWORD dw1, dw2;
	GetTickCount(&dw1, &dw2);
	{
		DWORD dw3, dw4;
		while(1) {
			GetTickCount(&dw3, &dw4);
			if((dw3-dw1)>10000) return;
		}
	}
}


#ifndef SKIP_2BL_VIDEO

DWORD Checkerboard(DWORD dwA, DWORD dwB) { return ( dwA | (dwB<<4) |	(dwA<<8) | (dwB<<12) | (dwA<<16) | (dwB<<20) | (dwA<<24) | (dwB<<28) ); }

void BootVgaInitialization() {
			////////////
			///  2bl Video init
			///////////////

	__asm__ __volatile__ ( "pushf ; cli" );


		{  // functionality as in 2bl
		const BYTE * pbaVideoInitSelected = baVideoInitTable2Alternate;
		const BYTE * pbaEdi, *pbaEsi, *pbaEcx;
		DWORD dwaTemp[8];
		DWORD dw=vinl(0xfd101000);
		int n, nDivisionResult;
		DWORD dwTemp;
		DWORD dwArg[0x20] ;

		if(dw & 0x000c0000) {  // selects between the two init tables based on resigter value
			pbaVideoInitSelected=baVideoInitTable2Standard;
		}


			// +9AF

		voutl(0xfd001220, 0x0f0f0f);  // enter this setup mode

			// form two 4-sample averages

		for(n=0;n<8;n++) {
			voutl(0xfd001228, 0x40000+(n^4));
			BootVideoDelay();
			dwaTemp[n^4]=vinl(0xfd00121c);
//			bprintf("  v2bl: %d: %x\n", n^4, dwaTemp[n^4]);
		}

		voutl(0xfd001220, 0x0f0f0f);  // exit setup mode

		dwaTemp[5]=(dwaTemp[4]+dwaTemp[5]+dwaTemp[6]+dwaTemp[7])>>2;  // sum1 seeing 5e..60
		dwaTemp[4]=(dwaTemp[0]+dwaTemp[1]+dwaTemp[2]+dwaTemp[3])>>2;  // sum2 seeing 6c..6d
		bprintf("  v2bl: sum1=%x, sum2=%x\n", dwaTemp[5], dwaTemp[4]);

			// sort the results into four categories

		if(dwaTemp[5] <= baVideoAvgCalibration[4]) {  // dwSum1 <= 0x56   CATEGORY 1/4

				nDivisionResult=((dwaTemp[5]-baVideoAvgCalibration[2])<<20) / (baVideoAvgCalibration[4]-baVideoAvgCalibration[2]);
				pbaEsi=&pbaVideoInitSelected[0x4c];
				pbaEdi=&pbaVideoInitSelected[0x39];
				if(nDivisionResult<0) dwaTemp[1]=0;

		} else { // ADFh dwSum1>0x56

			dwaTemp[0]=baVideoAvgCalibration[8];

			if(dwaTemp[5]>baVideoAvgCalibration[8]) { // >= 0x64  CATEGORY 2/4

				nDivisionResult=((dwaTemp[5]-baVideoAvgCalibration[8])<<20) / (baVideoAvgCalibration[10]-baVideoAvgCalibration[8]);

				pbaEsi=&pbaVideoInitSelected[0x13];
				pbaEdi=&pbaVideoInitSelected[0];

				if(nDivisionResult>0x100000) dwaTemp[1]=0; else dwaTemp[1]=nDivisionResult;  // bizarre but true

			} else { // dwSum1 between 0x57 and 0x64

				if(dwaTemp[5]<baVideoAvgCalibration[6]) { // B18 >= 0x5d  CATEGORY 3/4

					nDivisionResult=((dwaTemp[5]-baVideoAvgCalibration[6])<<20) / (baVideoAvgCalibration[6]-baVideoAvgCalibration[4]);  // edx

					dwaTemp[5]=(baVideoAvgCalibration[6]-baVideoAvgCalibration[4]);

					pbaEsi=&pbaVideoInitSelected[0x39];
					pbaEdi=&pbaVideoInitSelected[0x26];

					// nb - b54!!!
					dwaTemp[1]=nDivisionResult;

				} else { // B3D  CATEGORY 4/4

					nDivisionResult=((dwaTemp[5]-baVideoAvgCalibration[6])<<20) / (dwaTemp[0]-baVideoAvgCalibration[6]);  // edx

					dwaTemp[5]=(dwaTemp[0]-baVideoAvgCalibration[6]);

					pbaEsi=&pbaVideoInitSelected[0x26];
					pbaEdi=&pbaVideoInitSelected[0x13];

					// nb - b54!!!
					dwaTemp[1]=nDivisionResult;

				}
			}
		}

			// B57 - all four categories rejoin here

		{
			{
				int nd=pbaEdi[0], ns=pbaEsi[0];
				nd=nd * dwaTemp[1];
				ns = (ns * (0x100000 - dwaTemp[1]) );
				nd = nd + ns;
				dwaTemp[5]=(0x100000 - dwaTemp[1]);
				dwaTemp[0]=((nd+0x80000)>>20)&0xf;  // <----
			}
			{
				int nd=pbaEdi[1], ns=pbaEsi[1];
				ns=ns * dwaTemp[5];
				nd=nd * dwaTemp[1];
				ns+=nd;
				dwTemp=dwaTemp[1]; // this is held in ecx
				dwaTemp[1]=((ns+0x80000)>>20)&0xf;
			}
			{
				int nd=pbaEdi[2], ns=pbaEsi[2];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x40>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[3], ns=pbaEsi[3];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x28>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[4], ns=pbaEsi[4];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x48>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[5], ns=pbaEsi[5];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x30>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[6], ns=pbaEsi[6];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x54>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[7], ns=pbaEsi[7];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x20>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[8], ns=pbaEsi[8];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x38>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[9], ns=pbaEsi[9];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x50>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[0xa], ns=pbaEsi[0xa];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x4c>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[0xb], ns=pbaEsi[0xb];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x44>>2]=((ns+0x80000)>>20)&0xf;
			}
			{
				int nd=pbaEdi[0xc], ns=pbaEsi[0xc];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x3c>>2]=((ns+0x80000)>>20)&0xf;
			}
			{
				int nd=pbaEdi[0xd], ns=pbaEsi[0xd];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x34>>2]=((ns+0x80000)>>20)&0xf;
			}
			{
				int nd=pbaEdi[0xe], ns=pbaEsi[0xe];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x2c>>2]=((ns+0x80000)>>20)&0xf;
			}
			{
				int nd=pbaEdi[0xf], ns=pbaEsi[0xf];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x24>>2]=((ns+0x80000)>>20)&0xf;
			}

		}

			// now we look at the second average, again there are four categories
			// dwaTemp[5] destroyed here

		pbaEsi=&pbaVideoInitSelected[0];

		if( dwaTemp[4] <= baVideoAvgCalibration[5]) { // category 1/4
			nDivisionResult=((dwaTemp[4] - baVideoAvgCalibration[3]) <<20) / (baVideoAvgCalibration[5] - baVideoAvgCalibration[3]) ; // eax / edi
			pbaEcx =&pbaVideoInitSelected[0x4c];
			pbaEsi+=0x39;
			if(nDivisionResult<0) nDivisionResult=0;
		} else {  // d23
			dwaTemp[5] =baVideoAvgCalibration[9];
			if( dwaTemp[4] >= baVideoAvgCalibration[9]) { // category 2/4
				nDivisionResult = ((  dwaTemp[4]-baVideoAvgCalibration[9] )<<20) / (baVideoAvgCalibration[0xb]-baVideoAvgCalibration[9]); // eax/edi
				pbaEcx =&pbaVideoInitSelected[0x13];
				if(nDivisionResult > 0x100000) nDivisionResult=1;
			} else { // d53
				if( dwaTemp[4] < baVideoAvgCalibration[7]) { // category 3/4
					dwaTemp[5]=(baVideoAvgCalibration[7]-baVideoAvgCalibration[5]);
					nDivisionResult = ((  dwaTemp[4]-baVideoAvgCalibration[7] )<<20) / dwaTemp[5]; // eax/edi
					pbaEcx =&pbaVideoInitSelected[0x39];
					pbaEsi+=0x26;
				} else { // d75   category 4/4

					dwaTemp[5]=(dwaTemp[5] - baVideoAvgCalibration[7]);
					pbaEcx =&pbaVideoInitSelected[0x26];
					pbaEsi+=0x13;
					nDivisionResult = ((dwaTemp[4] - baVideoAvgCalibration[7] )<<20) / dwaTemp[5];
				}
			}
		}



			// d8e we rejoin main flow

		{
			int n, n1, n2;
			DWORD dwaFinalTable[0x9], dw;

			dwaTemp[5]=(0x100000 -nDivisionResult);
			n=pbaEcx[0x12] * dwaTemp[5]; // eax

			n1=pbaEsi[0x12] *nDivisionResult;
			n1+=n;
			dwArg[0x64>>2]=((n1+0x80000)>>20)&0xf;  // video_code_base trashed here

			n1=(pbaEsi[0x10]*nDivisionResult) + (pbaEcx[0x10] *dwaTemp[5]);
			n=((n1+0x80000)>>20)&0xf; // edi

			n1=(pbaEcx[0x11] *dwaTemp[5]) + (pbaEsi[0x11] *nDivisionResult);
			n2=((n1+0x80000)>>20)&0xf; // n2=esi

//			__asm__ __volatile__ ("wbinvd");  // <-- can cause death

				// combine this amazing amount of crap into a short table to be poked into the chip
				// surely this is all to do with 'protection', its all too stupid and pointless
				// the last one is especially stupid

			dwaFinalTable[0] = Checkerboard(dwaTemp[0], dwaTemp[1]);
			dwaFinalTable[1] = Checkerboard(dwArg[0x40>>2], dwArg[0x28>>2]);
			dwaFinalTable[2] = Checkerboard(dwArg[0x48>>2], dwArg[0x30>>2]);
			dwaFinalTable[3] = Checkerboard(dwArg[0x54>>2], dwArg[0x20>>2]);
			dwaFinalTable[4] = Checkerboard(dwArg[0x38>>2], dwArg[0x50>>2]);
			dwaFinalTable[5] = Checkerboard(dwArg[0x4c>>2], dwArg[0x44>>2]);
			dwaFinalTable[6] = Checkerboard(dwArg[0x3c>>2], dwArg[0x34>>2]);
			dwaFinalTable[7] = Checkerboard(dwArg[0x2c>>2], dwArg[0x24>>2]);

			dw=dwArg[0x64>>2];
			dw<<=2; dw|=n2;
			dw<<=3; dw|=n;
			dw<<=3; dw|=dwArg[0x64>>2];
			dw<<=2; dw|=n2;
			dw<<=3; dw|=n;
			dw<<=3; dw|=dwArg[0x64>>2];
			dw<<=2; dw|=n2;
			dw<<=3; dw|=n;
			dw<<=3; dw|=dwArg[0x64>>2];
			dw<<=2; dw|=n2;
			dw<<=3; dw|=n;
			dwaFinalTable[8] = dw;

				// issue the final table values to a fixed set of registers

			for(n=0;n<9;n++) {
				if(dwaFinalTable[n]==0) {
					voutl(0xfd000000, 0);
				} else {
//					bprintf("  v2bl: init %d: 0x%08X<-0x%08X\n", n, dwaVideoUnlockIoOfssets[n], dwaFinalTable[n]);
					voutl(dwaVideoUnlockIoOfssets[n], dwaFinalTable[n]);
				}
			}
		}
	}

}

#endif



BYTE BootVgaInitializationKernel(int nLinesPref, bool fFakeEncoderAllBlackForStartup)
{
//	int i=0;
//	int nVideoEncodingType=1; // pal??
//	int nVar14=1; // 1 or 2 ONLY
	int arg_8=1, /*nArg10=640, */arg_C=0x43, arg_14=0x01;
	DWORD dwStash=0;
	int nCtr=0;
	BYTE bAvPack;
	BYTE bTvStandard;
	DWORD dwTempIntState;

	BootPciInterruptGlobalStackStateAndDisable(&dwTempIntState);
	I2CTransmitWord(0x45, 0x6c46);

	bAvPack=I2CTransmitByteGetReturn(0x10, 0x04);
//	bAvPack=6;
	bTvStandard=I2CTransmitByteGetReturn(0x54, 0x5A);

	if(bTvStandard != 0x40) {
		bTvStandard = 0x80;
		bprintf("PAL\n");
		if(nLinesPref==576) if(bAvPack==6) bAvPack++;
		if(nLinesPref==600) bAvPack=9;
		// default to PAL but don't expect valid EEPROM
		// with cromwell and unlocked harddrive, serves no purpose
	} else {
		bprintf("NTSC\n");
		if(bAvPack==6) bAvPack = 8;  // NTSC only works on composite so far
	}

			////////////
			///  Kernel Video init
			///////////////

	IoOutputByte(0x80d3, 4);  // definitively kill video out

	*((volatile BYTE *)0xfd6013d4)=0x1f;
	*((volatile BYTE *)0xfd6013d5)=0x57;
	*((volatile BYTE *)0xfd0c03c4)=0x06;
	*((volatile BYTE *)0xfd0c03c5)=0x57;

		{
/* RJS  There is a nasty instability problem right here.
 * 	On my xbox,  this code hangs unless the xbox has been
 * 	powered off for ~10 minutes.  Other people have not reported
 * 	this yet.  Please send to the mailing list if you see this,
 * 	or fix it.  I added delay loops to verify it has nothing to
 * 	do with timing.

 andy@warmcat.com 2003-01-11  I saw the same behaviour during edits in BootResetAction.c
                              Adding a WATCHDOG()(); before the call to this function made it go away
 */

//			bool fMore=true;
//			int hackcount=0;
/*
			while(fMore  {  // some kind of wait for ready loop?
				dwStash=vinl(0xfd6806A0);  // var_18
				if( ! (((!(dwStash >> 4)) ^ (!dwStash)) & 1) ) fMore=false;
//				hackcount++;
			}
*/
			vgaout(0xfd6013D4, 0x1f, 0x57);
			vgaout(0xfd6013D4, 0x21, 0xff);
			voutl(0xfd680880, 0x21121111);

		}

		vgaout(0xfd0C03D4, 0x11, 0);
		vgaout(0xfd0C03D4, 0x1f, 0x57);

		bprintf("a\n");
		voutl(0xfd68050c,	vinl(0xfd68050c)|0x10020000);
		bprintf("b\n");

		voutb(0xfd0C03C3, 1);
		voutb(0xfd0C03C2, 0xe3);
		bprintf("c\n");

		voutl(0xfd680600, 0 /*0x0100030*/);  // this is actually set to a parameter to the kernel routine

		vgaout(0xfd6013D4, 0x11, 0);

		if(arg_8!=0) {
			voutl(0xfd680630, 0);
			voutl(0xfd6808c4, 0);
			voutl(0xfd68084c, 0);
		}

		vgaout(0xfd6013D4, 0x19, 0xe0);
		vgaout(0xfd6013D4, 0x28, 0x80);
		vgaout(0xfd6013D4, 0x28, 0x00);

		{
			int n=0, nCount=0x08;
			/* RJS */
			int nMode=bAvPack+1;
			if(nMode==9) nMode = 7;
			while(nCount--) {
				voutl(0xfd000000 + dwaKernelVideoLookupTable[n], dwaKernelVideoLookupTable[n+(nMode * 0x08)]);
				n++;
			}
		}
	TRACE;
		{
			int n=0;
			while(n<sizeof(baSequencerInit)) {
				vgaout(0xfd0C03C4, n, baSequencerInit[n]);
				n++;
			}
		}
	TRACE;

		{
			int n=0;
			while(n<sizeof(baGraInit)) {
				vgaout(0xfd0C03CE, n, baGraInit[n]);
				n++;
			}
		}

		{
			int n=0;
			while(n<sizeof(baAttrInit)) {
//				voutw(0xfd6013c0, n|(baAttrInit[n]<<8));
				voutb(0xfd6013c0, n);
				voutb(0xfd6013c0, baAttrInit[n]);
				n++;
			}
		}
	TRACE;
		voutb(0xfd6013c0, 0x20);
		vgaout(0xfd0C03D4, 0x11, 0);
		vgaout(0xfd0C03D4, 0x1f, 0x57);

	{
		DWORD dwAds[] = {
			0x680324, 0x680328, 0x68032c, 0x680330,
			0x680504, 0x680508, 0x680518, 0x680520,	
			0x680544, 0x680548, 0x680558, 0x680560, 
			0x680584, 0x680588, 0x680598, 0x6805a0, 
			0x6805c4, 0x6805c8, 0x6805d8, 0x6805e0,
			0x680604, 0x68060c, 0x680624, 0x680840
		};
		DWORD dwValue[][0x18] = {
			{ // 0
				0x615fe2f7, 0x21aabcb9, 0x282caad6, 0xce2b9a39, 0x00007702, 0x0003C20D, 0x00210008, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00210008, 0x0003C20D, 0x00007702, 0x0003C20D, 0x00210008, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00210008, 0x0003C20D, 0xFFFF0100, 0x00feebfd, 0x3FFFFFFd, 0x004e3fb9
			},
			{ //1
				0xffffffff, 0xF3FC68C7, 0x692DA0D6, 0xCEA52C1F, 0x00007702, 0x0003C20D, 0x00323232, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0xFFFF0134, 0x007CEBFD, 0x3FFFFFFF, 0x001DBCAD
			},
			{//2
				0xffffffff, 0xF3FC68C7, 0x692DA0D6, 0xCEA52C1F, 0x00007702, 0x0003C20D, 0x00323232, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0xFFFF0134, 0x007CEBFD, 0x3FFFFFFF, 0x001DBCAD
			},
			{//3
				0xffffffff, 0xF3FC68C7, 0x692DA0D6, 0xCEA52C1F, 0x00007702, 0x0003C20D, 0x00323232, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0xFFFF0134, 0x007CEBFD, 0x3FFFFFFF, 0x001DBCAD
			},
			{//4
				0xffffffff, 0xF3FC68C7, 0x692DA0D6, 0xCEA52C1F, 0x00007702, 0x0003C20D, 0x00323232, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0xFFFF0134, 0x007CEBFD, 0x3FFFFFFF, 0x001DBCAD
			},
			{//5
				0xffffffff, 0xF3FC68C7, 0x692DA0D6, 0xCEA52C1F, 0x00007702, 0x0003C20D, 0x00323232, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0xFFFF0134, 0x007CEBFD, 0x3FFFFFFF, 0x001DBCAD
			},
			{ // 6: composite PAL 640x480
				0x8b363bd7, 0xbcb86d9d, 0xcb0f6aec, 0xeb39e7a5, 0x00007702, 0x0003C20D, 0x0014180b, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00301834, 0x0003C20D, 0x00007702, 0x0003C20D, 0x00301834, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00301834, 0x0003C20D, 0xe0700105, 0x007fffad, 0x2ddf77ed, 0x001Dd414
			},
			{ // 7: NTSC
				0xffffffff, 0xF3FC68C7, 0x692DA0D6, 0xCEA52C1F, 0x00007702, 0x0003C20D, 0x00323232, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0xFFFF0134, 0x007CEBFD, 0x3FFFFFFF, 0x001DBCAD
			},
			{ // 8: composite PAL 640x576
				0x8b363bd7, 0xbcb86d9d, 0xcb0f6aec, 0xeb39e7a5, 0x00007702, 0x0003C20D, 0x0014180b, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00301834, 0x0003C20D, 0x00007702, 0x0003C20D, 0x00301834, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00301834, 0x0003C20D, 0xe0700105, 0x007fffad, 0x2ddf77ed, 0x001Dd414
			},
			{ // 9: composite PAL 800 x 600
				0x19EBA4DE, 0xCA40F23, 0x71BAD3DB, 0xA89B8064, 
				0x00007702, 0x0003C20D, 0x220C03, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x371629, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x371629, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x371629, 0x0003C20D,
				0x7CF80417, 0x1EE49, 0x1E57769C, 0x00ffffff
			},
		};

		int n=0;
		for(n=0;n<sizeof(dwAds)/sizeof(DWORD);n++) { voutl(0xfd000000|dwAds[n], dwValue[bAvPack][n]); }
	}

	TRACE;

	voutl(0xfd6806a0, (dwStash & 1)^1);
	vgaout(0xfd0C03D4, 0x28, 0x80 | arg_C);
/*
	for(i=0;i<3;i++) {
		while(vinb(0xfd6013da)&8) ;
		while(!(vinb(0xfd6013da)&8)) ;
	}
*/

//	voutl(0xfd600800, 0x23f); // arg14, 0x23f seen on good box
	arg_14=1; // dummy

		// frankenvideo results

	nCtr=0;
//	BYTE bTrue=bAvPack;
//	bAvPack=0;
	while(nCtr++<1) {
//		if(nCtr==2) bAvPack=bTrue;

	{
		volatile DWORD *pdw=(volatile DWORD *)0xfd680800;
		int n=0, n1=0;
		const DWORD dwa[][0x28] = {
/*	{ // scart (original )
			0x23f, 0x270, 0x23f, 0x249,
			0x24c, 0x0, 0x23f, 0x0,
			0x27f, 0x313, 0x257, 0x28f,
			0x2af, 0, 0x27f, 0,
			0x004e3fb9, 0, 0x10100111, 0x0,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				// +880->
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		} */

		{ // scart
			0x23f, 0x270, 0x23f, 0x249,
			0x24c, 0x0, 0x23f, 0x0,
			0x27f, 0x313, 0x257, 0x28f,
			0x2af, 0, 0x27f, 0,
			0x1dbcad, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				//+880->
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		/*
			0x004e3fb9, 0, 0x10100111, 0x0,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				//+880->
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		*/
		}, { // hdtv
			0x1df, 0x270, 0x1df, 0x218,
			0x21b, 0x0, 0x1df, 0x0,
			0x27f, 0x3af, 0x257, 0x29e,
			0x2be, 0, 0x27f, 0,
			0x1dbcad, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				//+880->
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		}, { // vga
			0x1df, 0x270, 0x1df, 0x218,
			0x21b, 0x0, 0x1df, 0x0,
			0x27f, 0x3af, 0x257, 0x29e,
			0x2be, 0, 0x27f, 0,
			0x1dbcad, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				/*+880->*/
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		}, {
			// type 3
			0x1df, 0x270, 0x1df, 0x218,
			0x21b, 0x0, 0x1df, 0x0,
			0x27f, 0x3af, 0x257, 0x29e,
			0x2be, 0, 0x27f, 0,
			0x1dbcad, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				/*+880->*/
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		}, { // svideo
			0x1df, 0x270, 0x1df, 0x218,
			0x21b, 0x0, 0x1df, 0x0,
			0x27f, 0x3af, 0x257, 0x29e,
			0x2be, 0, 0x27f, 0,
			0x1dbcad, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				/*+880->*/
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		}, { // type5
			0x1df, 0x270, 0x1df, 0x218,
			0x21b, 0x0, 0x1df, 0x0,
			0x27f, 0x3af, 0x257, 0x29e,
			0x2be, 0, 0x27f, 0,
			0x1dbcad, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				/*+880->*/
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		}, { // composite 480
			0x1df, 0x270, 0x1df, 0x218,
			0x21b, 0x0, 0x1df, 0x0,
			0x27f, 0x3af, 0x257, 0x29e,
			0x2be, 0, 0x27f, 0,
			0x1dbcad, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				//+880->
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		}, { // composite 576
			0x23f, 0x270, 0x23f, 0x249,
			0x24c, 0x0, 0x23f, 0x0,
			0x27f, 0x313, 0x257, 0x28f,
			0x2af, 0, 0x27f, 0,
			0xffffff, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				//+880->
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		}, { // composite 480 NTSC
			0x1df, 0x257, 0x1df, 0x20e,
			0x211, 0x0, 0x1df, 0x0,
			0x27f, 0x30f, 0x257, 0x28a,
			0x2aa, 0x0, 0x27f, 0x0,
			0x1dd414, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
			0x21101100, 0,0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		}, { // composite PAL 800 x 600
			0x257, 0x2B1, 0x257, 0x273, 0x276, 0x00, 0x257, 0x00,
			0x31F, 0x3E7, 0x2F7, 0x331, 0x351, 0x00, 0x31F, 0x00,
			0xFFFFFF, 0x00, 0x10100111, 0x801080, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x21101100, 0x00, 0x00, 0x10001000, 0x10000000, 0x10000000, 0x10000000, 0x10000000
			}
		};

		const BYTE baCrtc[][0x3F] = {
			{ // scart
				0x56, 0x4F, 0x4F, 0x9c, 0x51, 0x35, 0x6f, 0xf0, 0x00, 0x60, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0x45, /**/ 0x3F, 0x40, 0x00, 0x3F, 0x70, 0xE3, 0xFF, 0x3B, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x80, 0xFF, 0xFF, 0xA1, 0x00, 0x10, 0x20, 0xA3, 0x83, 0x00, 0x00, 0xFe, 0xFf, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x02, 0x30, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x03, 0x30,
				0x00
			},
			{ // hdtv
				0x6F, 0x4F, 0x4F, 0x93, 0x55, 0xB9, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0xE8, /**/  0xDF, 0x40, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x3B, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x80, 0xFF, 0xFF, 0xA1, 0x00, 0x10, 0x14, 0xA3, 0x83, 0x00, 0x00, 0xFF, 0xFD, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x02, 0x30, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x23, 0x30,
				0x00
			},
			{ // vga
				0x6F, 0x4F, 0x4F, 0x93, 0x55, 0xB9, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0xE8, /**/  0xDF, 0x40, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x3B, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x80, 0xFF, 0xFF, 0xA1, 0x00, 0x10, 0x14, 0xA3, 0x83, 0x00, 0x00, 0xFF, 0xFD, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x02, 0x30, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x23, 0x30,
				0x00
			},
			{ // unknown type 3
				0x6F, 0x4F, 0x4F, 0x93, 0x55, 0xB9, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0xE8, /**/  0xDF, 0x40, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x3B, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x80, 0xFF, 0xFF, 0xA1, 0x00, 0x10, 0x14, 0xA3, 0x83, 0x00, 0x00, 0xFF, 0xFD, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x02, 0x30, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x23, 0x30,
				0x00
			},
			{ // svideo
				0x6F, 0x4F, 0x4F, 0x93, 0x55, 0xB9, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0xE8, /**/  0xDF, 0x40, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x3B, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x80, 0xFF, 0xFF, 0xA1, 0x00, 0x10, 0x14, 0xA3, 0x83, 0x00, 0x00, 0xFF, 0xFD, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x02, 0x30, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x23, 0x30,
				0x00
			},
			{ // type 5
				0x6F, 0x4F, 0x4F, 0x93, 0x55, 0xB9, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0xE8, /**/  0xDF, 0x40, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x3B, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x80, 0xFF, 0xFF, 0xA1, 0x00, 0x10, 0x14, 0xA3, 0x83, 0x00, 0x00, 0xFF, 0xFD, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x02, 0x30, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x23, 0x30,
				0x00
			},
			{ // composite 480
				0x6F, 0x4F, 0x4F, 0x93, 0x55, 0xB9, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0xE8, /**/  0xDF, 0x40, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x3B, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x80, 0xFF, 0xFF, 0xA1, 0x00, 0x10, 0x14, 0xA3, 0x83, 0x00, 0x00, 0xFF, 0xFD, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x02, 0x30, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x23, 0x30,
				0x00
			},
			{ // composite 576
				0x56, 0x4F, 0x4F, 0x9c, 0x51, 0x35, 0x6f, 0xf0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x45, /**/  0x3f, 0x40, 0x00, 0x3F, 0x70, 0xE3, 0xFF, 0x30, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x80, 0xFF, 0xFF, 0xA1, 0x00, 0x10, 0x20, 0xA3, 0x83, 0x00, 0x00, 0xFF, 0xFf, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x22, 0x30, 0x00, 0xFF, 0xFF, 0xdF, 0x7F, 0x00, 0x20, 0x30,
				0x00
			},
			{// composite 480 NTSC overscan small
				0x56, 0x4F, 0x4F, 0x9c, 0x51, 0x35, 0x0b, 0x3e, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0xeb, /**/  0xdf, 0x40, 0x00, 0xdF, 0x0c, 0xE3, 0xFF, 0x30, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x29, 0xFe, 0xFd, 0xA1, 0x80, 0x10, 0x15, 0xA3, 0x83, 0x00, 0x00, 0xFe, 0xF3, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x00, 0x30, 0x00, 0xFF, 0x58, 0xFe, 0xeb, 0x00, 0x00, 0x31,
				0x00
			},
			{ // composite 800x600 MEDIUM -- type 9
				0x72 ,0x63 ,0x63 ,0x96 ,0x69 ,0x8C ,0xAD ,0xF0, 0x00 ,0x60 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00,
				0x70 ,/*0x22,*/ 0x57 ,0x90 ,0x00 ,0x57 ,0xAE ,0xE3, 0xFF ,0x30 ,0x2C ,0x85 ,0x00 ,0x00 ,0x00 , /*0x03, */
				0x41 ,0xFF ,0xEF ,0xA1 ,0x00 ,0x10 ,0x20 ,0xA3, 0x83 ,0x00 ,0x00 ,0xFF ,0xFF ,0xE0 ,0x00 ,0x03,
				0xFF ,0x00 ,0x00 ,0x11 ,0x02 ,0x02 ,0x22 ,0x30,	0x00 ,0xFF ,0xFF ,0xDF ,0x7F ,0x00 ,0x20 ,0x30,
				0x00
			}
		};

		const BYTE baConexant[][0x80] = {
/*
		{ // scart original
			0x62 , 0x06 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xd2 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0xff , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0xad , 0x3f , 0x03 , 0x4e , 0x00,
			0x0f, 0x00, 0x01, 0x28, 0x88, 0x74, 0x8a, 0x42,
			0x0a, 0x16, 0x22, 0xa6, 0x00, 0x14, 0x7e, 0x03,
			0x71, 0x2a, 0x40, 0x0a, 0x00, 0x50, 0xc7, 0xf1,
			0x0a, 0x24, 0xe8, 0x5b, 0x7b, 0x45,   0x88,   0x018,  // <--- A8==81, AA==49, AC == 8C normally
			0x75, 0x17, 0x2e, 0x00, 0x00, 0x20, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x98 , 0x9B , 0xC0 , 0xC0 , 0xe1,
			0x00 , 0x00 , 0x00 , 0x0c , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xf4 , 0xf6 , 0x54 , 0xA5 , 0x00 , 0x00
*/
		{ // scart
			0x62 , 0x06 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xd2 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0xff , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0xad , 0x3f , 0x03 , 0x4e , 0x00,
			0x0f, 0x00, 0x01, 0x28, 0x88, 0x74, 0x8a, 0x42,
			0x0a, 0x16, 0x22, 0xa6, 0x00, 0x14, 0x7e, 0x03,
			0x71, 0x2a, 0x40, 0x0a, 0x00, 0x50, 0xc7, 0xf1,
			0x0a, 0x24, 0xe8, 0x5b, 0x7b, 0x45,   0x88,   0x018,  // <--- A8==81, AA==49, AC == 8C normally
			0x75, 0x17, 0x2e, 0x00, 0x00, 0x20, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x98 , 0x9B , 0xC0 , 0xC0 , 0xe1,
			0x00 , 0x00 , 0x00 , 0x0c , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xf4 , 0xf6 , 0x54 , 0xA5 , 0x00 , 0x00
		}, {  // hdtv
			0x62 , 0x06 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xE4 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0x00 , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0x41 , 0x35 , 0x03 , 0x46 , 0x00,
			0x02, 0x00, 0x01, 0x60, 0x80, 0x8a, 0xa6, 0x68,
			0xc1, 0x2e, 0xf2, 0x27, 0x00, 0xb0, 0x0a, 0x0b,
			0x71, 0x5a, 0xe0, 0x36, 0x00, 0x50, 0x72, 0x1c,
			0x0d, 0x24, 0xf0, 0x58, 0x00, 0x00,   0x00,   0x0c,  // <--- A8==81, AA==49, AC == 8C normally
			0x8c, 0x79, 0x26, 0x52, 0x00, 0x24, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x9C , 0x9B , 0xC0 , 0xC0 , 0x19,
			0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xA2 , 0x25 , 0x54 , 0xA5 , 0x00 , 0x00
		}, {  // vga
			0x62 , 0x06 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xE4 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0x00 , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0x41 , 0x35 , 0x03 , 0x46 , 0x00,
			0x02, 0x00, 0x01, 0x60, 0x80, 0x8a, 0xa6, 0x68,
			0xc1, 0x2e, 0xf2, 0x27, 0x00, 0xb0, 0x0a, 0x0b,
			0x71, 0x5a, 0xe0, 0x36, 0x00, 0x50, 0x72, 0x1c,
			0x0d, 0x24, 0xf0, 0x58, 0x00, 0x00,   0x00,   0x0c,  // <--- A8==81, AA==49, AC == 8C normally
			0x8c, 0x79, 0x26, 0x52, 0x00, 0x24, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x9C , 0x9B , 0xC0 , 0xC0 , 0x19,
			0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xA2 , 0x25 , 0x54 , 0xA5 , 0x00 , 0x00
		}, {  // type 3
			0x62 , 0x06 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xE4 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0x00 , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0x41 , 0x35 , 0x03 , 0x46 , 0x00,
			0x02, 0x00, 0x01, 0x60, 0x80, 0x8a, 0xa6, 0x68,
			0xc1, 0x2e, 0xf2, 0x27, 0x00, 0xb0, 0x0a, 0x0b,
			0x71, 0x5a, 0xe0, 0x36, 0x00, 0x50, 0x72, 0x1c,
			0x0d, 0x24, 0xf0, 0x58, 0x00, 0x00,   0x00,   0x0c,  // <--- A8==81, AA==49, AC == 8C normally
			0x8c, 0x79, 0x26, 0x52, 0x00, 0x24, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x9C , 0x9B , 0xC0 , 0xC0 , 0x19,
			0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xA2 , 0x25 , 0x54 , 0xA5 , 0x00 , 0x00
		}, {  // svideo
			0x62 , 0x06 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xE4 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0x00 , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0x41 , 0x35 , 0x03 , 0x46 , 0x00,
			0x02, 0x00, 0x01, 0x60, 0x80, 0x8a, 0xa6, 0x68,
			0xc1, 0x2e, 0xf2, 0x27, 0x00, 0xb0, 0x0a, 0x0b,
			0x71, 0x5a, 0xe0, 0x36, 0x00, 0x50, 0x72, 0x1c,
			0x0d, 0x24, 0xf0, 0x58, 0x00, 0x00,   0x00,   0x0c,  // <--- A8==81, AA==49, AC == 8C normally
			0x8c, 0x79, 0x26, 0x52, 0x00, 0x24, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x9C , 0x9B , 0xC0 , 0xC0 , 0x19,
			0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xA2 , 0x25 , 0x54 , 0xA5 , 0x00 , 0x00
		}, {  // type5
			0x62 , 0x06 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xE4 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0x00 , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0x41 , 0x35 , 0x03 , 0x46 , 0x00,
			0x02, 0x00, 0x01, 0x60, 0x80, 0x8a, 0xa6, 0x68,
			0xc1, 0x2e, 0xf2, 0x27, 0x00, 0xb0, 0x0a, 0x0b,
			0x71, 0x5a, 0xe0, 0x36, 0x00, 0x50, 0x72, 0x1c,
			0x0d, 0x24, 0xf0, 0x58, 0x00, 0x00,   0x00,   0x0c,  // <--- A8==81, AA==49, AC == 8C normally
			0x8c, 0x79, 0x26, 0x52, 0x00, 0x24, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x9C , 0x9B , 0xC0 , 0xC0 , 0x19,
			0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xA2 , 0x25 , 0x54 , 0xA5 , 0x00 , 0x00
		}, {  // composite
// ORIGINAL 640 x 480
			0x62 , 0x06 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xE4 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0x00 , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0x41 , 0x35 , 0x03 , 0x46 , 0x00,
			0x02, 0x00, 0x01, 0x60, 0x80, 0x8a, 0xa6, 0x68,

			0xc1, 0x2e, 0xf2, 0x27, 0x00, 0xb0, 0x0a, 0x0b,
			0x71, 0x5a, 0xe0, 0x36, 0x00, 0x50, 0x72, 0x1c,
			0x0d, 0x24, 0xf0, 0x58, 0x81, 0x49,   0x8c,   0x0c,  // <--- A8==81, AA==49, AC == 8C normally
			0x8c, 0x79, 0x26, 0x52, 0x00, 0x24, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x9C , 0x9B , 0xC0 , 0xC0 , 0x19,
			0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xA2 , 0x25 , 0x54 , 0xA5 , 0x00 , 0x00

		}, { // 640x576

			0x62 , 0x05 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xd2 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0x00 , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0xad , 0x3f , 0x03 , 0x46 , 0x00,
			0x0f, 0x00, 0x01, 0x28, 0x88, 0x74, 0x8a, 0x42,
			0x0a, 0x16, 0x22, 0xa6, 0x00, 0x14, 0x7e, 0x03,
			0x71, 0x2a, 0x40, 0x0a, 0x00, 0x50, 0xc7, 0xf1,
//			0x0a, 0x24, 0xf0, 0x5e, 0xd9, 0x9a,   0x44,   0x18,  // <--- A8==81, AA==49, AC == 8C normally
			0x0a, 0x24, 0xf0, 0x5e, 0x81, 0x49,   0x8c,   0x18,  // <--- A8==81, AA==49, AC == 8C normally
			0x75, 0x17, 0x2e, 0x00, 0x00, 0x24, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x9C , 0x9B , 0xC0 , 0xC0 , 0x19,
			0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xA2 , 0x25 , 0x54 , 0xA5 , 0x00 , 0x00
		}, { // 640x480 NTSC overscan Small
			0x62 , 0x19 , 0x10 , 0x01 , 0x01 , 0x01 , 0x01 , 0x01,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x01 , 0x01 , 0x01 , 0x01,
			0x01 , 0x01 , 0x01 , 0x01 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xA4 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0xFF , 0x01 , 0x44,
			0xC0 , 0x00 , 0x18 , 0x15 , 0x4B , 0x00 , 0x46 , 0x00,
			0x02, 0x00, 0x01, 0x00, 0x80, 0x84, 0x96, 0x60,
			0x7D, 0x22, 0xd4, 0x27, 0x00, 0x10, 0x7e, 0x03,
			0x58, 0x4b, 0xE0, 0xa6, 0x92, 0x54, 0x0e, 0x88,
			0x0c, 0x0A, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00,
			0x00, 0x80, 0x20, 0x5A, 0x00, 0x24, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x9C , 0x80 , 0xC0 , 0xC0 , 0x19,
			0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 0x0F , 0xFC , 0x20,
			0xD0 , 0x6F , 0x0F , 0x00 , 0x00 , 0x0C , 0xF3 , 0x09,
			0xBD , 0x66 , 0xB5 , 0x90 , 0xB2 , 0x7D , 0x00 , 0x00
		}, { // 800x600 PAL overscan-corrected MEDIUM type 9
			0x62, 0x1B, 0x12, 0x03, 0x03, 0x03, 0x03, 0x03,
			0xC0, 0x00, 0x80, 0x9D, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x30, 0x00,
			0x00, 0x28, 0x80, 0xD2, 0x00, 0x00, 0x80, 0x80,
			0x80, 0x13, 0xDA, 0x4B, 0x28, 0xA3, 0x9F, 0x25,
			0xA3, 0x9F, 0x25, 0x00, 0x00, 0x00, 0x00, 0x44,
			0xC7, 0x00, 0x00, 0xAD, 0x3F, 0x03, 0x46, 0x00,
			0x02, 0x00, 0x01, 0xA0, 0x20, 0xA2, 0xC2, 0x8E,
			0xD7, 0x1E, 0x12, 0xB8, 0x00, 0xE8, 0xAF, 0x03,
			0xB2, 0x40, 0x58, 0x3A, 0x54, 0x53, 0x55, 0x55,
			0x0F, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x94,
			0x13, 0xE6, 0x20, 0x00, 0x00, 0x24, 0x00, 0x00,
			0x00, 0x00, 0x01, 0x9C, 0x1B, 0xC0, 0xC0, 0x19,  // b7 of C8 set low for luma LPF on Composite to stop colour fringing of HF luma
			0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x57, 0x20,
			0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05,
			0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, 0x00
		}
	};


		while(n < (sizeof(dwa[0])/sizeof(DWORD))) *pdw++=dwa[bAvPack][n++];

		for(n=0;n1<(sizeof(baCrtc[0]));n++) {
			if((n!=0x11) && (n!=0x1f)) {
				*((volatile BYTE *)0xfd6013d4)=(BYTE)n;
				*((volatile BYTE *)0xfd6013d5)=baCrtc[bAvPack][n1++];
			}
		}


		for(n=0;n<sizeof(baConexant[0]);n++) {
			if(n!=(0xb8>>1)) {
				if( (fFakeEncoderAllBlackForStartup) && ((n==(0xa8>>1)) || (n==(0xaa>>1)) || (n==(0xac>>1))) ) {
					I2CTransmitWord(0x45, (n<<9)|0);
					switch(n) {
						case (0xa8>>1):  bFinalConexantA8=baConexant[bAvPack][n]; break;
						case (0xaa>>1):  bFinalConexantAA=baConexant[bAvPack][n]; break;
						case (0xac>>1):  bFinalConexantAC=baConexant[bAvPack][n]; break;
					}
				} else {
					I2CTransmitWord(0x45, (n<<9)|baConexant[bAvPack][n]);
				}
			}
		}
	}

	voutl(0xfd001804, vinl(0xfd001804)|4);  // from kernel sub_0_80045C2A
	voutl(0xFD600140, 0);
	voutl(0xFD609140, 0);

	voutl(0xFD680600, 0);  // without this, blue horrors
//	(*(volatile unsigned int*)0xFD600800)= (60 * 1024 * 1024);

	VIDEO_WIDTH=640;
	VIDEO_HEIGHT=480;
	VIDEO_MARGINX=0;
	VIDEO_MARGINY=0;


	switch (bAvPack) {

		case 7: // composite+1 == 576 line request
			VIDEO_HEIGHT=576;
			VIDEO_MARGINX=40; // pixels
			VIDEO_MARGINY=40; // lines
		 break;
		case 9: // 800 x 600
			VIDEO_WIDTH=800;
			VIDEO_HEIGHT=600;
			VIDEO_MARGINY=20; // lines
		 break;
	}

//		vgaout(0xfd6013D4, 0x13, nArg10/8); // width/8

	switch(bAvPack) {  // radically changes colours if enabled on composite
		case 0:
			{
					// this might set up RGB out?
				voutl(0xFD680880, 0x21121111);
				voutl(0xFD609140, 0);
				voutl(0xFD682600, 0x100030);
				voutl(0xFD682630, 0);
				voutl(0xFD682634, 0);
				voutl(0xFD682638, 0);
				voutl(0xFD68263c, 0);
			}
			break;
		case 6:
			{
				voutl(0xFD680880, 0x21101100);
				voutl(0xFD682600,0 /* 0x100030 */);
/* rjs */
				voutl(0xFD682630, 2);
				voutl(0xFD682634, 0);
				voutl(0xFD682638, 0);
				voutl(0xFD68263c, 0);

				voutl(0xFD680324, 0x8b323bd7);
				voutl(0xFD680328, 0x66913ddf);
				voutl(0xFD68032c, 0x82afff2e);
				voutl(0xFD680330, 0xff4f218f);
				voutl(0xFD680504, 0x7702);
				voutl(0xFD680508, 0x3c20d);
				voutl(0xFD680518, 0x10101);
				voutl(0xFD680520, 0x3c20d);
				voutl(0xFD680544, 0x7702);
				voutl(0xFD680548, 0x3c20d);
				voutl(0xFD680558, 0x20202);
				voutl(0xFD680560, 0x3c20d);
/* end rjs */
			}
			break;
		case 7: // composite+1==576
			{
				voutl(0xFD680880, 0x21101100);
				voutl(0xFD682600,0 /* 0x100030 */);
				voutl(0xFD682630, 2);
				voutl(0xFD682634, 0);
				voutl(0xFD682638, 0);
				voutl(0xFD68263c, 0);

				voutl(0xFD680324, 0x388cd7be);
				voutl(0xFD680328, 0xfbdbebbc);
				voutl(0xFD68032c, 0xfddffffb);
				voutl(0xFD680330, 0xfffdffff);
				voutl(0xFD680504, 0x7702);
				voutl(0xFD680508, 0x3c20d);
				voutl(0xFD680518, 0x50505);
				voutl(0xFD680520, 0x3c20d);
				voutl(0xFD680544, 0x7702);
				voutl(0xFD680548, 0x3c20d);
				voutl(0xFD680558, 0x60606);
				voutl(0xFD680560, 0x3c20d);
			}
			break;
		case 8:  // NTSC 640x480
			{
				voutl(0xFD680880, 0x21101100);
				voutl(0xFD682600,0 /* 0x100030 */);
				voutl(0xFD682630, 2);
				voutl(0xFD682634, 0);
				voutl(0xFD682638, 0);
				voutl(0xFD68263c, 0);

				voutl(0xFD680324, 0x8b323bd7);
				voutl(0xFD680328, 0x66913ddf);
				voutl(0xFD68032c, 0x82afff2e);
				voutl(0xFD680330, 0xff4f218f);
				voutl(0xFD680504, 0x7702);
				voutl(0xFD680508, 0x3c20d);
				voutl(0xFD680518, 0x10101);
				voutl(0xFD680520, 0x3c20d);
				voutl(0xFD680544, 0x7702);
				voutl(0xFD680548, 0x3c20d);
				voutl(0xFD680558, 0x20202);
				voutl(0xFD680560, 0x3c20d);
			}
			break;
		case 9: // 800x600
			{
				voutl(0xFD680880, 0x21101100);
				voutl(0xFD682600,0 /* 0x100030 */);
/* rjs */
				voutl(0xFD682630, 2);
				voutl(0xFD682634, 0);
				voutl(0xFD682638, 0);
				voutl(0xFD68263c, 0);

				voutl(0xFD680324, 0x8b323bd7);
				voutl(0xFD680328, 0x66913ddf);
				voutl(0xFD68032c, 0x82afff2e);
				voutl(0xFD680330, 0xff4f218f);
				voutl(0xFD680504, 0x7702);
				voutl(0xFD680508, 0x3c20d);
				voutl(0xFD680518, 0x10101);
				voutl(0xFD680520, 0x3c20d);
				voutl(0xFD680544, 0x7702);
				voutl(0xFD680548, 0x3c20d);
				voutl(0xFD680558, 0x20202);
				voutl(0xFD680560, 0x3c20d);

				voutl(0xFD6808a0, 0x0);
				voutl(0xFD6808a4, 0xFF9007D3);
				voutl(0xFD6808a8, 0x5587D517);
				voutl(0xFD6808ac, 0xAF);
				voutl(0xFD6808b0, 0x0);
				voutl(0xFD6808b4, 0x0);
				voutl(0xFD6808b8, 0x0);
				voutl(0xFD6808bc, 0x0);
				voutl(0xFD6808c0, 0x0);
				voutl(0xFD6808c4, 0x40801080);
				voutl(0xFD6808c8, 0x0);
				voutl(0xFD6808cc, 0x0);
			}
			break;
	}

//	voutl(0xfd600800, 0x83c00000);   // new guy, move the video out of the way

			// enable VSYNC interrupt action

#ifndef XBE
	*((volatile DWORD *)0xfd600140)=0x1;  // enable VSYNC interrupts
	*((volatile DWORD *)0xfd600100)=0x1;  // clear VSYNC int
	*((volatile DWORD *)0xfd608000)=0x3c00000;  //
	*((volatile DWORD *)0xfd600140)=1;  // enable VSYNC int
	*((volatile DWORD *)0xfd000140)=0x1;  // enable VSYNC interrupts
	*((volatile DWORD *)0xfd000100)=0x1;  // clear VSYNC int
	*((volatile DWORD *)0xfd008000)=0x3c00000;  //
	*((volatile DWORD *)0xfd000140)=1;  // enable VSYNC int


//	BootVideoDelay();
	I2CTransmitWord(0x45, 0x6cc6);
#endif
	}

	BootPciInterruptGlobalPopState(dwTempIntState);
	TRACE;
	return bAvPack;
}

void BootVideoEnableOutput(BYTE bAvPack)
{

	IoOutputByte(0x80d3, 5);  // some kind of MCPX thing REQUIRED
	IoOutputByte(0x80d6, 5);  // some kind of MCPX thing seen in kernel, set to 4 or 5
	IoOutputByte(0x80d8, 4);  // some kind of MCPX thing seen in kernel, set to 4
	IoOutputByte(0x80d3, 4);  // some kind of MCPX thing REQUIRED


	vgaout(0xfd0C03C4, 1, 1); // screen on REQUIRED
	vgaout(0xfd0C03C4, 1, 1); // screen on REQUIRED
	voutb(0xfd6013c0, 0x01);

	voutb(0xfd0C03C2, 0xe3);
	vgaout(0xfd6013D4, 0x11, 0x20);

		// enable VSYNC interrupt action

#ifndef XBE
	*((volatile DWORD *)0xfd600140)=0x1;  // enable VSYNC interrupts
	*((volatile DWORD *)0xfd600100)=0x1;  // clear VSYNC int
	*((volatile DWORD *)0xfd608000)=0x3c00000;  //
	*((volatile DWORD *)0xfd600140)=1;  // enable VSYNC int
	*((volatile DWORD *)0xfd000140)=0x1;  // enable VSYNC interrupts
	*((volatile DWORD *)0xfd000100)=0x1;  // clear VSYNC int
	*((volatile DWORD *)0xfd008000)=0x3c00000;  //
	*((volatile DWORD *)0xfd000140)=1;  // enable VSYNC int
#endif

}


