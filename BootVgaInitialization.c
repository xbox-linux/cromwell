/*
 * video-related stuff
 * 2002-12-04  andy@warmcat.com  Video now working :-)
 */

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#include "boot.h"

void * memset(void *dest, int data,  size_t size);


// these two table are used to set the video mode

/*

const BYTE baConextantAddressesToWrite[] = { // text:8001364C dword_0_8001364C	dd
	0xd6, 0x2e, 0x32, 0x3c, 0x3e, 0x40, 0xc4, 0x6c, 0xce, 0xa0, 0x9e, 0x9c, 0x6c
};

const BYTE baConextantValuesToWriteDependingOnVideoType[][13] =
{
	{ 0x0c, 0xad, 0x48, 0x90, 0x8c, 0x8c, 0x01, 0x9c, 0xe1, 0x8c, 0x00, 0x00, 0x46 }, // dummy entry for illegal 0 option
	{ 0x0c, 0xad, 0x48, 0x90, 0x8c, 0x8c, 0x01, 0x9c, 0xe1, 0x8c, 0x00, 0x00, 0x46 },
	{ 0x0c, 0xaa, 0x49, 0x90, 0x8c, 0x8c, 0x01, 0x9c, 0xe1, 0x21, 0x00, 0x00, 0x46 },
	{ 0x0c, 0xab, 0x49, 0x90, 0x8c, 0x8c, 0x01, 0x9c, 0xe1, 0x21, 0x00, 0x00, 0x46 }
};

const WORD waConextantInitNon10CommandMSB[] = {
	0x2e00, 0x3000, 0x3228, 0x3480, 0x3800, 0x3a00, 0x3c80, 0x4080,
	0x6000, 0x6200, 0x6400, 0x6c46, 0x6e00, 0x700f, 0x7200, 0x7401,
	0xc401, 0xc69c, 0xc89b, 0xcac0, 0xccc0, 0xd840
};

const BYTE baConextantAddressesToWrite2[] = { // text:80013680 dword_0_80013680	dd
	0xd6, 0x36, 0x3e, 0x5a, 0x5c, 0x65, 0x68, 0x6a, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84,
	0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4,
	0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xce, 0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4,
	0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0x00, 0x00, 0x00
};

const DWORD dwaConextantValuesToWriteDependingOnVideoType2[] =  // munged up DWORDS, autually table of 0x3f byte arrays
{
	0x1FF80A4, 0x10004B15, 0x44857288, 0x26F213ED, 0x3730800,
	0x6E0240D, 0x0DA681000,	0x7CE40A0A, 0x129A8FCB, 0x5A258699,
	0x20FC0F19, 0x0F6FD0, 0x9F30C00,	0x90B566BD, 0x7DB2, 0x0A4000000,
	0x0F801FF80, 0x0D8CC0042, 0x75C9880, 0x26F213, 0x0D037F66,
	0x6E024, 0x0C2AF750, 0x0CA7BE40A, 0x0A4C89A8E, 0x195E2178,
	0x0D020FC0F, 0x0F6F, 0x0BD09F30C, 0x0B290B566, 0x7D, 0x80A40000,
	0x4B1501FF, 0x72881000,	0x13ED4485, 0x80026F2, 0x240D0373,
	0x100006E0, 0x80ADA68, 0x9ADC7CE4, 0x869912A7, 0x0F195A25,
	0x6FD020FC, 0x0C00000F,	0x66BD09F3, 0x7DB290B5, 0x0, 0xFF80A400,
	0x42F801, 0x9880D8CC, 0x0F213075C, 0x7F660026, 0x0E0240D03,
	0x0F7500006, 0x0E4080C2A, 0x0A79ADB7B, 0x2178A4C8, 0x0FC0F195E,
	0x0F6FD020, 0x0F30C0000, 0x0B566BD09, 0x7DB290, 0x0, 0x80A4,
	0x10004B15, 0x4C8E7288,	0x26F213ED, 0x3730800, 0x6E0240D,
	0x0DA681000, 0x58F02A0A, 0x8FA492CD, 0x5A257C0A, 0x20FC0F19,
	0x0F6FD0, 0x9F30C00, 0x90B566BD,	0x7DB2, 0x0A4000000, 0x0F8000080,
	0x0D8CC0042, 0x7649F80,	0x26F213, 0x0D037F66, 0x6E024, 0x0C2AF750,
	0x8057F00A, 0x3A438C48,	0x195A216F, 0x0D020FC0F, 0x0F6F,
	0x0BD09F30C, 0x0B290B566, 0x7D, 0x80E40000, 0x35410000, 0x76883C03,
	0x1615448C, 0x0B600A620, 0x230D03F7, 0x4AE106E0, 0x240B1555,
	0x9BD95EF0, 0x839833A3,	0x519522D, 0x6E402057, 0x0F51F47E,
	0x78D305F1, 0x0A55425A2, 0x0, 0x0FF80E400,	0x2E70800, 0x9A82D8E4,
	0x20162758, 0x81A00A6, 0x0E0230D0C, 0x4AE106, 0x0F0240C40,
	0x0A499D75C, 0x292DEB3A, 0x57051956, 0x7E6E4020, 0x0F10F51F4,
	0x0A278D305, 0x0A55425,	0x0, 0x0FF80D2, 0x28033FAD,	0x428A7488,
	0x0A622160A, 0x37E1400,	0x0A402A71, 0x0F1C75000, 0x5EF0240A,
	0x18A49AD9, 0x2E1775, 0x20570519, 0x0F47E6E40, 0x5F10F51,
	0x25A278D3, 0x0A554, 0x0D2000000, 0x0AF000080, 0x0D8EC02E3,
	0x2B5A9C82, 0x0A62216, 0x71038D76, 0x0A402A, 0x0C4E3950,
	0x0D75DF024, 0x5357A399, 0x195628FE, 0x40205705, 0x51F47E6E,
	0x0D305F10F, 0x5425A278, 0x0A5, 0x80A40000, 0x4B150000, 0x72881000,
	0x13ED4088, 0x80026F2, 0x240D0373, 0x100006E0, 0x200ADA68,
	0x9BD95EF0, 0x7AB77DA3,	0x0F19552E, 0x6FD020FC, 0x0C00000F,
	0x66BD09F3, 0x7DB290B5,	0x0, 0x80C000, 0x42F800, 0x9A80D8CC,
	0x0F2130756, 0x7F660026, 0x0E0240D03, 0x0F7500006, 0x0F0200C2A
};

*/

const BYTE baRegisterLoading[] = { //.text:80013408 dword_0_80013408	dd
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x20, 0x52, 0xd2, 0x33,
	0x39, 0x41,
		// 0x22

	0x56, 0x4f, 0x4f, 0x9c, 0x51, 0x35, 0x0b, 0x3e, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xeb, 0x0e, 0xdf, 0x00, 0x00, 0xdf, 0x0c, 0x30, 0xfe, 0x0f, 0x3a, 0x05, 0x80, 0x10, 0x00, 0x11,
	0xff, 0x00,
		// 0x44

	0x65, 0x59, 0x59, 0x89, 0x5b, 0xbf, 0x0b, 0x3e, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xe8, 0xbe, 0xdf, 0x00, 0x00, 0xdf, 0x0c, 0xe3, 0xff, 0x00, 0x3a, 0x05, 0x80, 0x10, 0x00, 0x11,
	0xff, 0x00
};


// these are some kind of calibration table
// used to assess results of initial sampling/averaging action

const BYTE baVideoAvgCalibration[]={  // unknown function, first few bytes must be present for video to come up with ms bootloader

	// b7 clear on all bytes

	32,
	78,
	78,  //
	62,
	86,  // first comparison
	67,
	93,
	74,
	100,
	80,
	106,
	85

};

const BYTE baVideoInitTable2Standard[] = {

	// 2 x 5 x 19-byte structs follow, all seem to follow 4, 4, 4, 4, 3 structure
	// only low 4 bits used on each byte

	// first set of 5 structs have 1 in first byte of triplet

9,9,14,8,  // always ... 14, 8
15,15,15,15,  // all 0F s appears only in second DWORD of struct, always same
9,9,14,8,  // always ... 14, 8
9,9,14,8,  // always ... 14, 8
1,0,0, // always ... 0

//0x13
9,9,14,8,
15,15,15,15,
9,9,14,8,
9,9,14,8,
1,1,0,

//0x26
9,9,14,8,
15,15,15,15,
9,9,14,8,
9,9,14,8,
1,2,0,

//0x39
10,11,14,8,
15,15,15,15,
10,11,14,8,
10,11,14,8,
1,2,0,

//0x4c
11,14,14,8,
15,15,15,15,
11,14,14,8,
11,14,14,8,
1,3,0

};

const BYTE baVideoInitTable2Alternate[] = {
	// second set of structs have 0 in first byte of triplet
	// these are chosen if b17b16 of a DWORD read of MMIO+101000h are not 11

9,9,14,8,
15,15,15,15,
9,9,14,8,
9,9,14,8,
0,0,0,

9,9,14,8,
15,15,15,15,
9,9,14,8,
9,9,14,8,
0,1,0,

9,9,14,8,
15,15,15,15,
9,9,14,8,
9,9,14,8,
0,2,0,

10,11,14,8,
15,15,15,15,
10,11,14,8,
10,11,14,8,
0,2,0,

11,14,14,8,
15,15,15,15,
11,14,14,8,
11,14,14,8,
0,3,0
};


const BYTE baGraInit[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0f, 0xff };
const BYTE baSequencerInit[] = { 0x03, 0x21, 0x0f, 0x00, 0x06 };
const BYTE baAttrInit[] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x01, 0x4a, 0x0f, 0x00, 0x00
 };
const DWORD dwaVideoUnlockIoOfssets[] = {
	0xfd00122c, 0xfd00123c, 0xfd001230, 0xfd001240, 0xfd001234, 0xfd001244, 0xfd001238, 0xfd001248, 0xfd001214
};

/*
 dword_0_80012BD0	dd 3020100h, 7060504h, 0B0A0908h, 0F0E0D0Ch, 0F4A01h
				       ; DATA XREF: AvSetDisplayMode+2FFo
.text:80012BE4		       db 0
.text:80012BE5 byte_0_80012BE5 db 3 dup(0)	       ; DATA XREF: AvSetDisplayMode+310o
.text:80012BE8 dword_0_80012BE8	dd 0, 0F054000h	       ; DATA XREF: AvSetDisplayMode+2E0o
.text:80012BF0		       db 0FFh
.text:80012BF1 byte_0_80012BF1 db 3 dup(0)	       ; DATA XREF: AvSetDisplayMode+2F1o
.text:80012BF4 dword_0_80012BF4	dd 0F2103h	       ; DATA XREF: AvSetDisplayMode+2C1o
.text:80012BF8		       db 6
.text:80012BF9 dword_0_80012BF9	dd 0		       ; DATA XREF: AvSetDisplayMode+2D2o
.text:80012BFD		       align 4
.text:80012C00 dword_0_80012C00	dd 680880h	       ; DATA XREF: AvSetDisplayMode+3D2r
.text:80012C04		       dd 6 dup(21101100h), 21101101h, 21101100h, 21101115h, 21101111h
.text:80012C04		       dd 21101100h, 21101155h,	21101151h, 3 dup(21101100h), 21101101h
.text:80012C04		       dd 21101100h, 0
*/

//; dword_0_80012C50  DATA XREF: AvSetDisplayMode+282o

const DWORD dwaKernelVideoLookupTable[] = {
	0x680898, 0x68089C, 0x6808C0, 0x6808C4, 0x68084C,	0x680630,
	0x680800, 0x680804, 0x680808, 0x68080C, 0x680810, 0x680814,
	0x680818, 0x680820, 0x680824, 0x680828, 0x68082C, 0x680830,
	0x680834, 0x680838, 0x680848, 0x680680, 0x680684, 0x680688,
	0x68068C, 0x680690,

	// mode 1
	0x10000000, 0x10000000, 0x0, 0x40801080, 0x801080, 0x2, 0x1DF, 0x20C,
	0x1DF, 0x1EA, 0x1ED, 0x0, 0x1DF, 0x27F, 0x307, 0x257,
	0x28D, 0x2AD, 0x0, 0x27F, 0x10100111,	0x0C6ED0, 0x20D, 0x9B,
	0x26C, 0x0,

	// mode 2
	0x10000000, 0x10000000, 0x0, 0x40801080,	0x801080, 0x2, 0x1DF, 0x20C, 
	0x1DF, 0x1EA, 0x1ED, 0x0, 0x1DF, 0x2CF, 0x365, 0x2A7,
	0x2DF, 0x2FF, 0x0, 0x2CF, 0x10100111,	0x0DF05C, 0x20D, 0x0AE,
	0x2B8, 0x0,

	//mode 3
	0x10000000, 0x10000000, 0x0, 0x40801080, 0x801080,
	0x2, 0x1DF, 0x20C, 0x1DF, 0x1E8, 0x1EB, 0x0, 0x1DF, 0x27F, 0x3B5,
	0x257,	0x2B7, 0x2D7, 0x0, 0x27F, 0x10100111,	0x0F387C, 0x271,
	0x0BE,	0x2F8, 0x0,
	//mode 4
	0x10000000, 0x10000000, 0x0, 0x40801080, 0x801080,
	0x2, 0x1DF, 0x20C, 0x1DF, 0x1E8, 0x1EB, 0x0, 0x1DF, 0x2CF, 0x419,
	0x2AF,	0x30B, 0x32B, 0x0, 0x2CF, 0x10100111,	0x10D2A4, 0x271,
	0x0D2,	0x348, 0x0,
	// mode 5
	0x10000000, 0x10000000, 0x0, 0x40801080, 0x801080,
	0x2, 0x23F, 0x270, 0x23F, 0x249, 0x24C, 0x0, 0x23F, 0x27F, 0x313,
	0x257,	0x28F, 0x2AF, 0x0, 0x27F, 0x10100111,	0x0F07A8, 0x271,
	0x9D, 0x276, 0x0,
	// mode 6
	0x10000000, 0x10000000, 0x0, 0x40801080,	0x801080,
	0x2, 0x23F, 0x270, 0x23F, 0x249, 0x24C, 0x0, 0x23F, 0x2CF, 0x375,
	0x2AF,	0x2E1, 0x302, 0x0, 0x2CF, 0x10100111,	0x10E62C, 0x271,
	0x0B1,	0x2C4, 0x0,
	// mode 7
	0x10000000, 0x10000000, 0x0, 0x40801080, 0x801080,
	0x2, 0x1DF, 0x20C, 0x1DF, 0x1E8, 0x1EE, 0x0, 0x1DF, 0x2CF, 0x359,
	0x29F,	0x2E1, 0x320, 0x0, 0x2CF, 0x10100011,	0x35A, 0x1, 0x0AB,
	0x2AE,	0x1,
	// mode 8
	0x10000000, 0x10000000, 0x0,	0x40801080, 0x801080, 0x2,
	0x1DF,	0x20C, 0x1DF, 0x1E8, 0x1EE,	0x0, 0x1DF, 0x2CF, 0x359, 0x29F,
	0x2E1,	0x320, 0x0, 0x2CF, 0x10100111, 0x30A,	0x1, 0x0AB, 0x2AE,
	0x1,

};
/*
		// this seems wrong, but the disassembly shows only one 0x10000000 here

	0x0AA94000, 0x10000000, 0x0, 0x40801080, 0x801080, 0x3, 
	0x2CF, 0x2ED, 0x2CF, 0x2D4, 0x2D9, 0x0, 0x2CF, 0x4FF, 0x671, 0x4FF,
	0x545, 0x595,	0x0A0, 0x45F, 0x10100011, 0x672, 0x1,	0x14A, 0x528, 
	0x1,

	0x2,

	0x10000000, 0x10000000, 0x0, 0x40801080, 0x801080, 0x3, 0x2CF, 0x2ED,
	0x2CF,	0x2D4, 0x2D9, 0x0, 0x2CF, 0x4FF, 0x671, 0x4CF, 0x545, 0x595,
	0x0, 0x4FF, 0x10100011, 0x672, 0x1, 0x14A, 0x528, 0x1,

	0x10000000, 0x10000000,
	0x0, 0x40801080,	0x801080, 0x3, 0x2CF, 0x2ED,	0x2CF, 0x2D4, 0x2D9,
	0x0, 0x2CF, 0x4FF, 0x671, 0x4FF, 0x545, 0x595, 0x0, 0x4FF, 0x10100111,
	0x672,	0x1, 0x14A, 0x528, 0x1, 0x71AE000,

	0x7183800, 0x0, 0x40801080,
	0x801080, 0x3, 0x437, 0x464, 0x43C, 0x43c, 0x446, 0x0,	0x437,
	0x77F,	0x897, 0x7AA, 0x7AB, 0x803,	0x0F0, 0x68F, 0x10133011,
	0x898,	0x1, 0x1B8, 0x6E0, 0x1, 0x10000000, 0x7183800,

	0x0, 0x40801080,
	0x801080, 0x3, 0x437, 0x464, 0x43C, 0x43c, 0x446, 0x0,	0x437,
	0x77F,	0x897, 0x759, 0x7AB, 0x803,	0x0, 0x77F, 0x10133011, 0x898,
	0x1, 0x1B8, 0x6E0, 0x1,

	0x10000000, 0x10000000, 0x0, 0x40801080, 0x801080,
	0x3, 0x437, 0x464, 0x43B, 0x43b, 0x445, 0x0, 0x437, 0x77F, 0x897,
	0x7AB,	0x7AC, 0x804, 0x0, 0x77F, 0x10133111,	0x898, 0x1, 0x1B8,
	0x6E0,	0x1,

	0x10000000, 0x10000000, 0x0,	0x40801080, 0x801080, 0x2,
	0x1DF,	0x20C, 0x1DF, 0x1EA, 0x1ED,	0x0, 0x1DF, 0x27F, 0x355, 0x2A7,
	0x2B0,	0x2D0, 0x0, 0x27F, 0x10100111, 0x0DF05C, 0x20D, 0x0AE,
	0x2B8,	0x0,

	0x10000000, 0x10000000, 0x0,	0x40801080, 0x801080, 0x2,
	0x1DF,	0x20C, 0x1DF, 0x1EA, 0x1ED,	0x0, 0x1DF, 0x27F, 0x419, 0x2A7,
	0x2DB,	0x2FB, 0x0, 0x27F, 0x10100111, 0x0DF05C, 0x20D, 0x0AE,
	0x2B8,	0x0,

	0x10000000, 0x10000000, 0x0,	0x40801080, 0x801080, 0x2,
	0x1DF,	0x20C, 0x1DF, 0x1E8, 0x1EE,	0x0, 0x1DF, 0x2CF, 0x359, 0x2CF,
	0x2DF,	0x31E, 0x20, 0x2AD, 0x10100011, 0x35A, 0x1, 0x0AB, 0x2AE,
	0x1,

	0x10000000, 0x10000000, 0x0, 0x40801080, 0x801080, 0x2, 0x23F,
	0x270,	0x23F, 0x249, 0x24C, 0x0, 0x23F, 0x27F, 0x363, 0x257, 0x2B0,
	0x2D0,	0x0, 0x27F, 0x10100111, 0x0F07A8, 0x271, 0x9D,	0x276, 0x0


};
*/



// memory mapped IO

void vgaout(unsigned int port, unsigned char reg, unsigned char data) {
	*((volatile unsigned char*)(port)) = reg;
	*((volatile unsigned char*)(port+1)) = data;
}

void voutb(int nAds, BYTE b) {
	*((volatile unsigned char*)(nAds)) = b;
}
void voutw(int nAds, WORD w) {
	*((volatile WORD*)(nAds)) = w;
}
void voutl(int nAds, DWORD dw) {
	*((volatile DWORD*)(nAds)) = dw;
}
BYTE vinb(int nAds) {
	return *((volatile unsigned char*)(nAds)) ;
}

void GetTickCount(DWORD * pdw1, DWORD * pdw2)
{
	DWORD dw1, dw2;
	
	__asm__ __volatile__ (
		"rdtsc " : "=a" (dw1), "=d" (dw2)
	);
	*pdw1=dw1; *pdw2=dw2;
}

void BootVideoDelay(void)
{
	DWORD dw1, dw2;
	GetTickCount(&dw1, &dw2);
	{
		DWORD dw3, dw4;
		while(1) {
			GetTickCount(&dw3, &dw4);
			if((dw3-dw1)>10000) return;
		}
	}
}


DWORD vinl(int nAds) {
	return *((volatile DWORD*)(nAds)) ;
}

#ifndef SKIP_2BL_VIDEO

DWORD Checkerboard(DWORD dwA, DWORD dwB) { return ( dwA | (dwB<<4) |	(dwA<<8) | (dwB<<12) | (dwA<<16) | (dwB<<20) | (dwA<<24) | (dwB<<28) ); }

void BootVgaInitialization() {
			////////////
			///  2bl Video init
			///////////////

	__asm__ __volatile__ ( "pushf ; cli" );


		{  // functionality as in 2bl
		const BYTE * pbaVideoInitSelected = baVideoInitTable2Alternate;
		const BYTE * pbaEdi, *pbaEsi, *pbaEcx;
		DWORD dwaTemp[8];
		DWORD dw=vinl(0xfd101000);
		int n, nDivisionResult;
		DWORD dwTemp;
		DWORD dwArg[0x20] ;

		if(dw & 0x000c0000) {  // selects between the two init tables based on resigter value
			pbaVideoInitSelected=baVideoInitTable2Standard;
		}


			// +9AF

		voutl(0xfd001220, 0x0f0f0f);  // enter this setup mode

			// form two 4-sample averages

		for(n=0;n<8;n++) {
			voutl(0xfd001228, 0x40000+(n^4));
			BootVideoDelay();
			dwaTemp[n^4]=vinl(0xfd00121c);
//			bprintf("  v2bl: %d: %x\n", n^4, dwaTemp[n^4]);
		}

		voutl(0xfd001220, 0x0f0f0f);  // exit setup mode

		dwaTemp[5]=(dwaTemp[4]+dwaTemp[5]+dwaTemp[6]+dwaTemp[7])>>2;  // sum1 seeing 5e..60
		dwaTemp[4]=(dwaTemp[0]+dwaTemp[1]+dwaTemp[2]+dwaTemp[3])>>2;  // sum2 seeing 6c..6d
//		bprintf("  v2bl: sum1=%x, sum2=%x\n", dwaTemp[5], dwaTemp[4]);

			// sort the results into four categories

		if(dwaTemp[5] <= baVideoAvgCalibration[4]) {  // dwSum1 <= 0x56   CATEGORY 1/4

				nDivisionResult=((dwaTemp[5]-baVideoAvgCalibration[2])<<20) / (baVideoAvgCalibration[4]-baVideoAvgCalibration[2]);
				pbaEsi=&pbaVideoInitSelected[0x4c];
				pbaEdi=&pbaVideoInitSelected[0x39];
				if(nDivisionResult<0) dwaTemp[1]=0;

		} else { // ADFh dwSum1>0x56

			dwaTemp[0]=baVideoAvgCalibration[8];

			if(dwaTemp[5]>baVideoAvgCalibration[8]) { // >= 0x64  CATEGORY 2/4

				nDivisionResult=((dwaTemp[5]-baVideoAvgCalibration[8])<<20) / (baVideoAvgCalibration[10]-baVideoAvgCalibration[8]);

				pbaEsi=&pbaVideoInitSelected[0x13];
				pbaEdi=&pbaVideoInitSelected[0];

				if(nDivisionResult>0x100000) dwaTemp[1]=0; else dwaTemp[1]=nDivisionResult;  // bizarre but true

			} else { // dwSum1 between 0x57 and 0x64

				if(dwaTemp[5]<baVideoAvgCalibration[6]) { // B18 >= 0x5d  CATEGORY 3/4

					nDivisionResult=((dwaTemp[5]-baVideoAvgCalibration[6])<<20) / (baVideoAvgCalibration[6]-baVideoAvgCalibration[4]);  // edx

					dwaTemp[5]=(baVideoAvgCalibration[6]-baVideoAvgCalibration[4]);

					pbaEsi=&pbaVideoInitSelected[0x39];
					pbaEdi=&pbaVideoInitSelected[0x26];

					// nb - b54!!!
					dwaTemp[1]=nDivisionResult;

				} else { // B3D  CATEGORY 4/4

					nDivisionResult=((dwaTemp[5]-baVideoAvgCalibration[6])<<20) / (dwaTemp[0]-baVideoAvgCalibration[6]);  // edx

					dwaTemp[5]=(dwaTemp[0]-baVideoAvgCalibration[6]);

					pbaEsi=&pbaVideoInitSelected[0x26];
					pbaEdi=&pbaVideoInitSelected[0x13];

					// nb - b54!!!
					dwaTemp[1]=nDivisionResult;

				}
			}
		}

			// B57 - all four categories rejoin here

		{
			{
				int nd=pbaEdi[0], ns=pbaEsi[0];
				nd=nd * dwaTemp[1];
				ns = (ns * (0x100000 - dwaTemp[1]) );
				nd = nd + ns;
				dwaTemp[5]=(0x100000 - dwaTemp[1]);
				dwaTemp[0]=((nd+0x80000)>>20)&0xf;  // <----
			}
			{
				int nd=pbaEdi[1], ns=pbaEsi[1];
				ns=ns * dwaTemp[5];
				nd=nd * dwaTemp[1];
				ns+=nd;
				dwTemp=dwaTemp[1]; // this is held in ecx
				dwaTemp[1]=((ns+0x80000)>>20)&0xf;
			}
			{
				int nd=pbaEdi[2], ns=pbaEsi[2];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x40>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[3], ns=pbaEsi[3];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x28>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[4], ns=pbaEsi[4];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x48>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[5], ns=pbaEsi[5];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x30>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[6], ns=pbaEsi[6];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x54>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[7], ns=pbaEsi[7];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x20>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[8], ns=pbaEsi[8];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x38>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[9], ns=pbaEsi[9];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x50>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[0xa], ns=pbaEsi[0xa];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x4c>>2]=((ns+0x80000)>>20)&0xf;
			}

			{
				int nd=pbaEdi[0xb], ns=pbaEsi[0xb];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x44>>2]=((ns+0x80000)>>20)&0xf;
			}
			{
				int nd=pbaEdi[0xc], ns=pbaEsi[0xc];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x3c>>2]=((ns+0x80000)>>20)&0xf;
			}
			{
				int nd=pbaEdi[0xd], ns=pbaEsi[0xd];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x34>>2]=((ns+0x80000)>>20)&0xf;
			}
			{
				int nd=pbaEdi[0xe], ns=pbaEsi[0xe];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x2c>>2]=((ns+0x80000)>>20)&0xf;
			}
			{
				int nd=pbaEdi[0xf], ns=pbaEsi[0xf];
				ns=ns * dwaTemp[5];
				nd=nd * dwTemp; // from ecx
				ns+=nd;
				dwArg[0x24>>2]=((ns+0x80000)>>20)&0xf;
			}

		}

			// now we look at the second average, again there are four categories
			// dwaTemp[5] destroyed here

		pbaEsi=&pbaVideoInitSelected[0];

		if( dwaTemp[4] <= baVideoAvgCalibration[5]) { // category 1/4
			nDivisionResult=((dwaTemp[4] - baVideoAvgCalibration[3]) <<20) / (baVideoAvgCalibration[5] - baVideoAvgCalibration[3]) ; // eax / edi
			pbaEcx =&pbaVideoInitSelected[0x4c];
			pbaEsi+=0x39;
			if(nDivisionResult<0) nDivisionResult=0;
		} else {  // d23
			dwaTemp[5] =baVideoAvgCalibration[9];
			if( dwaTemp[4] >= baVideoAvgCalibration[9]) { // category 2/4
				nDivisionResult = ((  dwaTemp[4]-baVideoAvgCalibration[9] )<<20) / (baVideoAvgCalibration[0xb]-baVideoAvgCalibration[9]); // eax/edi
				pbaEcx =&pbaVideoInitSelected[0x13];
				if(nDivisionResult > 0x100000) nDivisionResult=1;
			} else { // d53
				if( dwaTemp[4] < baVideoAvgCalibration[7]) { // category 3/4
					dwaTemp[5]=(baVideoAvgCalibration[7]-baVideoAvgCalibration[5]);
					nDivisionResult = ((  dwaTemp[4]-baVideoAvgCalibration[7] )<<20) / dwaTemp[5]; // eax/edi
					pbaEcx =&pbaVideoInitSelected[0x39];
					pbaEsi+=0x26;
				} else { // d75   category 4/4

					dwaTemp[5]=(dwaTemp[5] - baVideoAvgCalibration[7]);
					pbaEcx =&pbaVideoInitSelected[0x26];
					pbaEsi+=0x13;
					nDivisionResult = ((dwaTemp[4] - baVideoAvgCalibration[7] )<<20) / dwaTemp[5];
				}
			}
		}



			// d8e we rejoin main flow

		{
			int n, n1, n2;
			DWORD dwaFinalTable[0x9], dw;

			dwaTemp[5]=(0x100000 -nDivisionResult);
			n=pbaEcx[0x12] * dwaTemp[5]; // eax

			n1=pbaEsi[0x12] *nDivisionResult;
			n1+=n;
			dwArg[0x64>>2]=((n1+0x80000)>>20)&0xf;  // video_code_base trashed here

			n1=(pbaEsi[0x10]*nDivisionResult) + (pbaEcx[0x10] *dwaTemp[5]);
			n=((n1+0x80000)>>20)&0xf; // edi

			n1=(pbaEcx[0x11] *dwaTemp[5]) + (pbaEsi[0x11] *nDivisionResult);
			n2=((n1+0x80000)>>20)&0xf; // n2=esi

//			__asm__ __volatile__ ("wbinvd");  // <-- can cause death

				// combine this amazing amount of crap into a short table to be poked into the chip
				// surely this is all to do with 'protection', its all too stupid and pointless
				// the last one is especially stupid

			dwaFinalTable[0] = Checkerboard(dwaTemp[0], dwaTemp[1]);
			dwaFinalTable[1] = Checkerboard(dwArg[0x40>>2], dwArg[0x28>>2]);
			dwaFinalTable[2] = Checkerboard(dwArg[0x48>>2], dwArg[0x30>>2]);
			dwaFinalTable[3] = Checkerboard(dwArg[0x54>>2], dwArg[0x20>>2]);
			dwaFinalTable[4] = Checkerboard(dwArg[0x38>>2], dwArg[0x50>>2]);
			dwaFinalTable[5] = Checkerboard(dwArg[0x4c>>2], dwArg[0x44>>2]);
			dwaFinalTable[6] = Checkerboard(dwArg[0x3c>>2], dwArg[0x34>>2]);
			dwaFinalTable[7] = Checkerboard(dwArg[0x2c>>2], dwArg[0x24>>2]);

			dw=dwArg[0x64>>2];
			dw<<=2; dw|=n2;
			dw<<=3; dw|=n;
			dw<<=3; dw|=dwArg[0x64>>2];
			dw<<=2; dw|=n2;
			dw<<=3; dw|=n;
			dw<<=3; dw|=dwArg[0x64>>2];
			dw<<=2; dw|=n2;
			dw<<=3; dw|=n;
			dw<<=3; dw|=dwArg[0x64>>2];
			dw<<=2; dw|=n2;
			dw<<=3; dw|=n;
			dwaFinalTable[8] = dw;

				// issue the final table values to a fixed set of registers

			for(n=0;n<9;n++) {
				if(dwaFinalTable[n]==0) {
					voutl(0xfd000000, 0);
				} else {
//					bprintf("  v2bl: init %d: 0x%02X\n", n, dwaFinalTable[n]);
					voutl(dwaVideoUnlockIoOfssets[n], dwaFinalTable[n]);
				}
			}
		}
	}

		*((volatile BYTE *)0xfd009100)=0x0;
		*((volatile BYTE *)0xfd009140)=0x0;
		*((volatile BYTE *)0xfd009200)=0x0;
		*((volatile BYTE *)0xfd009400)=0x0;
		*((volatile BYTE *)0xfd009410)=0x0;
		*((volatile BYTE *)0xfd009420)=0x0;

	__asm__ __volatile__ ( "sti" );

}

#endif



BYTE BootVgaInitializationKernel(int nLinesPref)
{
	int i=0;
//	int nVideoEncodingType=1; // pal??
	int nVar14=1; // 1 or 2 ONLY
	int arg_8=1, nArg10=640, arg_C=0x43, arg_14=0x01;
	DWORD dwStash=0;
	int nCtr=0;
	BYTE bAvPack;
	BYTE bTvStandard;

#ifndef XBE
	__asm__ __volatile__ ( "pushf ; cli" );
#endif

	I2CTransmitWord(0x45, 0x6c46);

	bAvPack=I2CTransmitByteGetReturn(0x10, 0x04);
	bTvStandard=I2CTransmitByteGetReturn(0x54, 0x5A);

	if(bTvStandard != 0x40) {
		bTvStandard = 0x80;
		bprintf("PAL\n");
		if(nLinesPref==576) if(bAvPack==6) bAvPack++;
		// default to PAL but don't expect valid EEPROM
		// with cromwell and unlocked harddrive, serves no purpose
	} else {
		bprintf("NTSC\n");
		if(bAvPack==6) bAvPack = 8;  // NTSC only works on composite so far
	}

			////////////
			///  Kernel Video init
			///////////////

	IoOutputByte(0x80d3, 5);  // definitively kill video out


	*((volatile BYTE *)0xfd6013d4)=0x1f;
	*((volatile BYTE *)0xfd6013d5)=0x57;
	*((volatile BYTE *)0xfd0c03c4)=0x06;
	*((volatile BYTE *)0xfd0c03c5)=0x57;
	WATCHDOG;
	TRACE;

		{
/* RJS  There is a nasty instability problem right here.
 * 	On my xbox,  this code hangs unless the xbox has been
 * 	powered off for ~10 minutes.  Other people have not reported
 * 	this yet.  Please send to the mailing list if you see this,
 * 	or fix it.  I added delay loops to verify it has nothing to
 * 	do with timing.

 andy@warmcat.com 2003-01-11  I saw the same behaviour during edits in BootResetAction.c
                              Adding a WATCHDOG; before the call to this function made it go away
 */

			bool fMore=true;
//			int hackcount=0;

			while(fMore /* && (hackcount < 3000) */) {  // some kind of wait for ready loop?
				dwStash=vinl(0xfd6806A0);  // var_18
				if( ! (((!(dwStash >> 4)) ^ (!dwStash)) & 1) ) fMore=false;
//				hackcount++;
			}

//	bprintf("hackcount %d\n\r", hackcount);
			vgaout(0xfd6013D4, 0x1f, 0x57);
	TRACE;
			vgaout(0xfd6013D4, 0x21, 0xff);
	TRACE;

			voutl(0xfd680880, 0x21121111);
	TRACE;

		}
	WATCHDOG;
	TRACE;

		vgaout(0xfd6013D4, 0x13, nArg10/8); // width/8
/*
		{
			int n=0;
			while(n<13) {
				I2CTransmitWordDelay(0x45, (((DWORD)baConextantAddressesToWrite[n])<<8)|baConextantValuesToWriteDependingOnVideoType[nVideoEncodingType][n]);
				n++;
			}
		}

		for(i=0;i<(sizeof(waConextantInitNon10CommandMSB)/sizeof(WORD));i++) {  // issue Encoder setup table
			I2CTransmitWordDelay(0x45, waConextantInitNon10CommandMSB[i]);
		}

		for(i=0;i<0x3f;i++) {  // issue Encoder setup table
			I2CTransmitWordDelay(0x45,
				(((DWORD)baConextantAddressesToWrite2[i])<<8)|
				*(((BYTE *)&dwaConextantValuesToWriteDependingOnVideoType2[0])+(0x3f * nVideoEncodingType)+i),
				false
			);
		}
*/
		vgaout(0xfd0C03D4, 0x11, 0);
		vgaout(0xfd0C03D4, 0x1f, 0x57);

			WATCHDOG;
			TRACE;

		IoOutputByte(0x80d6, 4);
		IoOutputByte(0x80d8, 4);

		voutl(0xfd68050c,	vinl(0xfd68050c)|0x10020000);

		voutb(0xfd0C03C3, 1);
		voutb(0xfd0C03C2, 0xe3);

		voutl(0xfd680600, 0x0100030);  // this is actually set to a parameter to the kernel routine

	WATCHDOG;
	TRACE;
		vgaout(0xfd6013D4, 0x11, 0);

		if(arg_8!=0) {
			voutl(0xfd680630, 0);
			voutl(0xfd6808c4, 0);
			voutl(0xfd68084c, 0);
		}

		vgaout(0xfd6013D4, 0x19, 0xe0);
		vgaout(0xfd6013D4, 0x28, 0x80);
		vgaout(0xfd6013D4, 0x28, 0x00);

		{
			int n=0, nCount=0x1a;
			/* RJS */
			int nMode=bAvPack+1;
			if(nMode==9) nMode = 7; // for NTSC
			while(nCount--) {
				voutl(0xfd000000 + dwaKernelVideoLookupTable[n], dwaKernelVideoLookupTable[n+(nMode * 0x1a)]);
				n++;
			}
		}
	WATCHDOG;
	TRACE;
		{
			int n=0;
			while(n<sizeof(baSequencerInit)) {
				vgaout(0xfd0C03C4, n, baSequencerInit[n]);
				n++;
			}
		}
	WATCHDOG;
	TRACE;

		{
			int n=0;
			while(n<sizeof(baGraInit)) {
				vgaout(0xfd0C03CE, n, baGraInit[n]);
				n++;
			}
		}

		{
			int n=0;
			while(n<sizeof(baAttrInit)) {
//				voutw(0xfd6013c0, n|(baAttrInit[n]<<8));
				voutb(0xfd6013c0, n);
				voutb(0xfd6013c0, baAttrInit[n]);
				n++;
			}
		}
	WATCHDOG;
	TRACE;
		voutb(0xfd6013c0, 0x20);


		for(i=0;i<0x22;i++) {  // issue more CRTC register setup
			BYTE bReg=baRegisterLoading[i];
			BYTE b=baRegisterLoading[(0x22 * nVar14)+i];
			switch(bReg) {
				case 0x13:
					// .text:800310B0		       mov     cl, byte	ptr [ebp+arg_10]
					b=(BYTE)nArg10/8;
					break;
				case 0x19:
					b|=(nArg10/64)&0xe0;
					break;
				case 0x25:
					b|=(nArg10/512)&0x20;
					break;
			}
			vgaout(0xfd0C03D4, bReg, b);
		}
		vgaout(0xfd0C03D4, 0x11, 0);
		vgaout(0xfd0C03D4, 0x1f, 0x57);

	{
		DWORD dwAds[] = {
			0x680324, 0x680328, 0x68032c, 0x680330, 0x680504, 0x680508, 0x680518, 0x680520,
			0x680544, 0x680548, 0x680558, 0x680560, 0x680584, 0x680588, 0x680598, 0x6805a0,
			0x6805c4, 0x6805c8, 0x6805d8, 0x6805e0, 0x680604, 0x68060c, 0x680624, 0x680840
		};
		DWORD dwValue[][0x18] = {
			{ //
				0x615fe2f7, 0x21aabcb9, 0x282caad6, 0xce2b9a39, 0x00007702, 0x0003C20D, 0x00210008, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00210008, 0x0003C20D, 0x00007702, 0x0003C20D, 0x00210008, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00210008, 0x0003C20D, 0xFFFF0100, 0x00feebfd, 0x3FFFFFFd, 0x004e3fb9
			},
			{
				0xffffffff, 0xF3FC68C7, 0x692DA0D6, 0xCEA52C1F, 0x00007702, 0x0003C20D, 0x00323232, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0xFFFF0134, 0x007CEBFD, 0x3FFFFFFF, 0x001DBCAD
			},
			{
				0xffffffff, 0xF3FC68C7, 0x692DA0D6, 0xCEA52C1F, 0x00007702, 0x0003C20D, 0x00323232, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0xFFFF0134, 0x007CEBFD, 0x3FFFFFFF, 0x001DBCAD
			},
			{
				0xffffffff, 0xF3FC68C7, 0x692DA0D6, 0xCEA52C1F, 0x00007702, 0x0003C20D, 0x00323232, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0xFFFF0134, 0x007CEBFD, 0x3FFFFFFF, 0x001DBCAD
			},
			{
				0xffffffff, 0xF3FC68C7, 0x692DA0D6, 0xCEA52C1F, 0x00007702, 0x0003C20D, 0x00323232, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0xFFFF0134, 0x007CEBFD, 0x3FFFFFFF, 0x001DBCAD
			},
			{
				0xffffffff, 0xF3FC68C7, 0x692DA0D6, 0xCEA52C1F, 0x00007702, 0x0003C20D, 0x00323232, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00333333, 0x0003C20D, 0xFFFF0134, 0x007CEBFD, 0x3FFFFFFF, 0x001DBCAD
			},
			{
				0x8b363bd7, 0xbcb86d9d, 0xcb0f6aec, 0xeb39e7a5, 0x00007702, 0x0003C20D, 0x0014180b, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00301834, 0x0003C20D, 0x00007702, 0x0003C20D, 0x00301834, 0x0003C20D,
				0x00007702, 0x0003C20D, 0x00301834, 0x0003C20D, 0xe0700105, 0x007fffad, 0x2ddf77ed, 0x001Dd414
			}
		};

		int n=0;
		for(n=0;n<sizeof(dwAds)/sizeof(DWORD);n++) { voutl(0xfd000000|dwAds[n], dwValue[bAvPack][n]); }
	}

	WATCHDOG;
	TRACE;

	voutl(0xfd6806a0, (dwStash & 1)^1);
	vgaout(0xfd0C03D4, 0x28, 0x80 | arg_C);
/*
	for(i=0;i<3;i++) {
		while(vinb(0xfd6013da)&8) ;
		while(!(vinb(0xfd6013da)&8)) ;
	}
*/

//	voutl(0xfd600800, 0x23f); // arg14, 0x23f seen on good box
	arg_14=1; // dummy

		// frankenvideo results

	nCtr=0;
//	BYTE bTrue=bAvPack;
//	bAvPack=0;
	while(nCtr++<1) {
//		if(nCtr==2) bAvPack=bTrue;

	{
		volatile DWORD *pdw=(volatile DWORD *)0xfd680800;
		int n=0, n1=0;
		const DWORD dwa[][0x28] = {
/*	{ // scart (original )
			0x23f, 0x270, 0x23f, 0x249,
			0x24c, 0x0, 0x23f, 0x0,
			0x27f, 0x313, 0x257, 0x28f,
			0x2af, 0, 0x27f, 0,
			0x004e3fb9, 0, 0x10100111, 0x0,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				// +880->
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		} */

		{ // scart
			0x23f, 0x270, 0x23f, 0x249,
			0x24c, 0x0, 0x23f, 0x0,
			0x27f, 0x313, 0x257, 0x28f,
			0x2af, 0, 0x27f, 0,
			0x1dbcad, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				//+880->
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		/*
			0x004e3fb9, 0, 0x10100111, 0x0,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				//+880->
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		*/
		}, { // hdtv
			0x1df, 0x270, 0x1df, 0x218,
			0x21b, 0x0, 0x1df, 0x0,
			0x27f, 0x3af, 0x257, 0x29e,
			0x2be, 0, 0x27f, 0,
			0x1dbcad, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				//+880->
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		}, { // vga
			0x1df, 0x270, 0x1df, 0x218,
			0x21b, 0x0, 0x1df, 0x0,
			0x27f, 0x3af, 0x257, 0x29e,
			0x2be, 0, 0x27f, 0,
			0x1dbcad, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				/*+880->*/
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		}, {
			// type 3
			0x1df, 0x270, 0x1df, 0x218,
			0x21b, 0x0, 0x1df, 0x0,
			0x27f, 0x3af, 0x257, 0x29e,
			0x2be, 0, 0x27f, 0,
			0x1dbcad, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				/*+880->*/
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		}, { // svideo
			0x1df, 0x270, 0x1df, 0x218,
			0x21b, 0x0, 0x1df, 0x0,
			0x27f, 0x3af, 0x257, 0x29e,
			0x2be, 0, 0x27f, 0,
			0x1dbcad, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				/*+880->*/
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		}, { // type5
			0x1df, 0x270, 0x1df, 0x218,
			0x21b, 0x0, 0x1df, 0x0,
			0x27f, 0x3af, 0x257, 0x29e,
			0x2be, 0, 0x27f, 0,
			0x1dbcad, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				/*+880->*/
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		}, { // composite 480
			0x1df, 0x270, 0x1df, 0x218,
			0x21b, 0x0, 0x1df, 0x0,
			0x27f, 0x3af, 0x257, 0x29e,
			0x2be, 0, 0x27f, 0,
			0x1dbcad, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				//+880->
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		}, { // composite 576
			0x23f, 0x270, 0x23f, 0x249,
			0x24c, 0x0, 0x23f, 0x0,
			0x27f, 0x313, 0x257, 0x28f,
			0x2af, 0, 0x27f, 0,
			0xffffff, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
				//+880->
			0x21101100, 0x0, 0x0, 0x10001000,
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		}, { // composite 480 NTSC
			0x1df, 0x257, 0x1df, 0x20e,
			0x211, 0x0, 0x1df, 0x0,
			0x27f, 0x30f, 0x257, 0x28a,
			0x2aa, 0x0, 0x27f, 0x0,
			0x1dd414, 0, 0x10100111, 0x00801080,
			0,0,0,0,
			0,0,0,0,
			0,0,0,0,
			0x21101100, 0,0, 0x10001000, 
			0x10000000, 0x10000000, 0x10000000, 0x10000000
		}
		};

		const BYTE baCrtc[][0x3F] = {
			{ // scart
				0x56, 0x4F, 0x4F, 0x9c, 0x51, 0x35, 0x6f, 0xf0, 0x00, 0x60, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0x45, /**/ 0x3F, 0x40, 0x00, 0x3F, 0x70, 0xE3, 0xFF, 0x3B, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x80, 0xFF, 0xFF, 0xA1, 0x00, 0x10, 0x20, 0xA3, 0x83, 0x00, 0x00, 0xFe, 0xFf, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x02, 0x30, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x03, 0x30,
				0x00 
			},
			{ // hdtv
				0x6F, 0x4F, 0x4F, 0x93, 0x55, 0xB9, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0xE8, /**/  0xDF, 0x40, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x3B, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x80, 0xFF, 0xFF, 0xA1, 0x00, 0x10, 0x14, 0xA3, 0x83, 0x00, 0x00, 0xFF, 0xFD, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x02, 0x30, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x23, 0x30,
				0x00
			},
			{ // vga
				0x6F, 0x4F, 0x4F, 0x93, 0x55, 0xB9, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0xE8, /**/  0xDF, 0x40, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x3B, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x80, 0xFF, 0xFF, 0xA1, 0x00, 0x10, 0x14, 0xA3, 0x83, 0x00, 0x00, 0xFF, 0xFD, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x02, 0x30, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x23, 0x30,
				0x00
			},
			{ // unknown type 3
				0x6F, 0x4F, 0x4F, 0x93, 0x55, 0xB9, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0xE8, /**/  0xDF, 0x40, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x3B, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x80, 0xFF, 0xFF, 0xA1, 0x00, 0x10, 0x14, 0xA3, 0x83, 0x00, 0x00, 0xFF, 0xFD, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x02, 0x30, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x23, 0x30,
				0x00
			},
			{ // svideo
				0x6F, 0x4F, 0x4F, 0x93, 0x55, 0xB9, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0xE8, /**/  0xDF, 0x40, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x3B, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x80, 0xFF, 0xFF, 0xA1, 0x00, 0x10, 0x14, 0xA3, 0x83, 0x00, 0x00, 0xFF, 0xFD, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x02, 0x30, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x23, 0x30,
				0x00
			},
			{ // type 5
				0x6F, 0x4F, 0x4F, 0x93, 0x55, 0xB9, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0xE8, /**/  0xDF, 0x40, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x3B, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x80, 0xFF, 0xFF, 0xA1, 0x00, 0x10, 0x14, 0xA3, 0x83, 0x00, 0x00, 0xFF, 0xFD, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x02, 0x30, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x23, 0x30,
				0x00
			},
			{ // composite 480
				0x6F, 0x4F, 0x4F, 0x93, 0x55, 0xB9, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0xE8, /**/  0xDF, 0x40, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x3B, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x80, 0xFF, 0xFF, 0xA1, 0x00, 0x10, 0x14, 0xA3, 0x83, 0x00, 0x00, 0xFF, 0xFD, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x02, 0x30, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x23, 0x30,
				0x00
			},
			{ // composite 576
				0x56, 0x4F, 0x4F, 0x9c, 0x51, 0x35, 0x6f, 0xf0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x45, /**/  0x3f, 0x40, 0x00, 0x3F, 0x70, 0xE3, 0xFF, 0x30, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x80, 0xFF, 0xFF, 0xA1, 0x00, 0x10, 0x20, 0xA3, 0x83, 0x00, 0x00, 0xFF, 0xFf, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x22, 0x30, 0x00, 0xFF, 0xFF, 0xdF, 0x7F, 0x00, 0x20, 0x30,
				0x00
			},
			{// composite 480 NTSC overscan small
				0x56, 0x4F, 0x4F, 0x9c, 0x51, 0x35, 0x0b, 0x3e, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0xeb, /**/  0xdf, 0x40, 0x00, 0xdF, 0x0c, 0xE3, 0xFF, 0x30, 0x3A, 0x85, 0x00, 0x00, 0x00, /**/
				0x29, 0xFe, 0xFd, 0xA1, 0x80, 0x10, 0x15, 0xA3, 0x83, 0x00, 0x00, 0xFe, 0xF3, 0xE0, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x02, 0x02, 0x00, 0x30, 0x00, 0xFF, 0x58, 0xFe, 0xeb, 0x00, 0x00, 0x31,
				0x00
			},
		};

		const BYTE baConexant[][0x80] = {
/*
		{ // scart original
			0x62 , 0x06 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xd2 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0xff , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0xad , 0x3f , 0x03 , 0x4e , 0x00,
			0x0f, 0x00, 0x01, 0x28, 0x88, 0x74, 0x8a, 0x42,
			0x0a, 0x16, 0x22, 0xa6, 0x00, 0x14, 0x7e, 0x03,
			0x71, 0x2a, 0x40, 0x0a, 0x00, 0x50, 0xc7, 0xf1,
			0x0a, 0x24, 0xe8, 0x5b, 0x7b, 0x45,   0x88,   0x018,  // <--- A8==81, AA==49, AC == 8C normally
			0x75, 0x17, 0x2e, 0x00, 0x00, 0x20, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x98 , 0x9B , 0xC0 , 0xC0 , 0xe1,
			0x00 , 0x00 , 0x00 , 0x0c , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xf4 , 0xf6 , 0x54 , 0xA5 , 0x00 , 0x00
*/
		{ // scart
			0x62 , 0x06 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xd2 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0xff , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0xad , 0x3f , 0x03 , 0x4e , 0x00,
			0x0f, 0x00, 0x01, 0x28, 0x88, 0x74, 0x8a, 0x42,
			0x0a, 0x16, 0x22, 0xa6, 0x00, 0x14, 0x7e, 0x03,
			0x71, 0x2a, 0x40, 0x0a, 0x00, 0x50, 0xc7, 0xf1,
			0x0a, 0x24, 0xe8, 0x5b, 0x7b, 0x45,   0x88,   0x018,  // <--- A8==81, AA==49, AC == 8C normally
			0x75, 0x17, 0x2e, 0x00, 0x00, 0x20, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x98 , 0x9B , 0xC0 , 0xC0 , 0xe1,
			0x00 , 0x00 , 0x00 , 0x0c , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xf4 , 0xf6 , 0x54 , 0xA5 , 0x00 , 0x00
		}, {  // hdtv
			0x62 , 0x06 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xE4 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0x00 , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0x41 , 0x35 , 0x03 , 0x46 , 0x00,
			0x02, 0x00, 0x01, 0x60, 0x80, 0x8a, 0xa6, 0x68,
			0xc1, 0x2e, 0xf2, 0x27, 0x00, 0xb0, 0x0a, 0x0b,
			0x71, 0x5a, 0xe0, 0x36, 0x00, 0x50, 0x72, 0x1c,
			0x0d, 0x24, 0xf0, 0x58, 0x00, 0x00,   0x00,   0x0c,  // <--- A8==81, AA==49, AC == 8C normally
			0x8c, 0x79, 0x26, 0x52, 0x00, 0x24, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x9C , 0x9B , 0xC0 , 0xC0 , 0x19,
			0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xA2 , 0x25 , 0x54 , 0xA5 , 0x00 , 0x00
		}, {  // vga
			0x62 , 0x06 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xE4 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0x00 , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0x41 , 0x35 , 0x03 , 0x46 , 0x00,
			0x02, 0x00, 0x01, 0x60, 0x80, 0x8a, 0xa6, 0x68,
			0xc1, 0x2e, 0xf2, 0x27, 0x00, 0xb0, 0x0a, 0x0b,
			0x71, 0x5a, 0xe0, 0x36, 0x00, 0x50, 0x72, 0x1c,
			0x0d, 0x24, 0xf0, 0x58, 0x00, 0x00,   0x00,   0x0c,  // <--- A8==81, AA==49, AC == 8C normally
			0x8c, 0x79, 0x26, 0x52, 0x00, 0x24, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x9C , 0x9B , 0xC0 , 0xC0 , 0x19,
			0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xA2 , 0x25 , 0x54 , 0xA5 , 0x00 , 0x00
		}, {  // type 3
			0x62 , 0x06 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xE4 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0x00 , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0x41 , 0x35 , 0x03 , 0x46 , 0x00,
			0x02, 0x00, 0x01, 0x60, 0x80, 0x8a, 0xa6, 0x68,
			0xc1, 0x2e, 0xf2, 0x27, 0x00, 0xb0, 0x0a, 0x0b,
			0x71, 0x5a, 0xe0, 0x36, 0x00, 0x50, 0x72, 0x1c,
			0x0d, 0x24, 0xf0, 0x58, 0x00, 0x00,   0x00,   0x0c,  // <--- A8==81, AA==49, AC == 8C normally
			0x8c, 0x79, 0x26, 0x52, 0x00, 0x24, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x9C , 0x9B , 0xC0 , 0xC0 , 0x19,
			0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xA2 , 0x25 , 0x54 , 0xA5 , 0x00 , 0x00
		}, {  // svideo
			0x62 , 0x06 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xE4 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0x00 , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0x41 , 0x35 , 0x03 , 0x46 , 0x00,
			0x02, 0x00, 0x01, 0x60, 0x80, 0x8a, 0xa6, 0x68,
			0xc1, 0x2e, 0xf2, 0x27, 0x00, 0xb0, 0x0a, 0x0b,
			0x71, 0x5a, 0xe0, 0x36, 0x00, 0x50, 0x72, 0x1c,
			0x0d, 0x24, 0xf0, 0x58, 0x00, 0x00,   0x00,   0x0c,  // <--- A8==81, AA==49, AC == 8C normally
			0x8c, 0x79, 0x26, 0x52, 0x00, 0x24, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x9C , 0x9B , 0xC0 , 0xC0 , 0x19,
			0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xA2 , 0x25 , 0x54 , 0xA5 , 0x00 , 0x00
		}, {  // type5
			0x62 , 0x06 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xE4 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0x00 , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0x41 , 0x35 , 0x03 , 0x46 , 0x00,
			0x02, 0x00, 0x01, 0x60, 0x80, 0x8a, 0xa6, 0x68,
			0xc1, 0x2e, 0xf2, 0x27, 0x00, 0xb0, 0x0a, 0x0b,
			0x71, 0x5a, 0xe0, 0x36, 0x00, 0x50, 0x72, 0x1c,
			0x0d, 0x24, 0xf0, 0x58, 0x00, 0x00,   0x00,   0x0c,  // <--- A8==81, AA==49, AC == 8C normally
			0x8c, 0x79, 0x26, 0x52, 0x00, 0x24, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x9C , 0x9B , 0xC0 , 0xC0 , 0x19,
			0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xA2 , 0x25 , 0x54 , 0xA5 , 0x00 , 0x00
		}, {  // composite
// ORIGINAL 640 x 480
			0x62 , 0x06 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xE4 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0x00 , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0x41 , 0x35 , 0x03 , 0x46 , 0x00,
			0x02, 0x00, 0x01, 0x60, 0x80, 0x8a, 0xa6, 0x68,
			0xc1, 0x2e, 0xf2, 0x27, 0x00, 0xb0, 0x0a, 0x0b,
			0x71, 0x5a, 0xe0, 0x36, 0x00, 0x50, 0x72, 0x1c,
#if 0  // do not start off all black
			0x0d, 0x24, 0xf0, 0x58, 0x81, 0x49,   0x8c,   0x0c,  // <--- A8==81, AA==49, AC == 8C normally
#else
			0x0d, 0x24, 0xf0, 0x58, 0x00, 0x00,   0x00,   0x0c,  // <--- A8==81, AA==49, AC == 8C normally
#endif
			0x8c, 0x79, 0x26, 0x52, 0x00, 0x24, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x9C , 0x9B , 0xC0 , 0xC0 , 0x19,
			0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xA2 , 0x25 , 0x54 , 0xA5 , 0x00 , 0x00

		}, { // 640x576

			0x62 , 0x05 , 0x12 , 0x06 , 0x06 , 0x06 , 0x06 , 0x06,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x00 , 0x00 , 0x00 , 0x00,
			0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xd2 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0x00 , 0x00 , 0x44,
			0xC7 , 0x00 , 0x00 , 0xad , 0x3f , 0x03 , 0x46 , 0x00,
			0x0f, 0x00, 0x01, 0x28, 0x88, 0x74, 0x8a, 0x42,
			0x0a, 0x16, 0x22, 0xa6, 0x00, 0x14, 0x7e, 0x03,
			0x71, 0x2a, 0x40, 0x0a, 0x00, 0x50, 0xc7, 0xf1,
#if 0  // do not start off all black
			0x0a, 0x24, 0xf0, 0x5e, 0xd9, 0x9a,   0x44,   0x18,  // <--- A8==81, AA==49, AC == 8C normally
#else
			0x0a, 0x24, 0xf0, 0x5e, 0x00, 0x00,   0x00,   0x18,  // <--- A8==81, AA==49, AC == 8C normally
#endif
			0x75, 0x17, 0x2e, 0x00, 0x00, 0x24, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x9C , 0x9B , 0xC0 , 0xC0 , 0x19,
			0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 0x05 , 0x57 , 0x20,
			0x40 , 0x6E , 0x7E , 0xF4 , 0x51 , 0x0F , 0xF1 , 0x05,
			0xD3 , 0x78 , 0xA2 , 0x25 , 0x54 , 0xA5 , 0x00 , 0x00
		}, { // 640x480 NTSC overscan Small
			0x62 , 0x19 , 0x10 , 0x01 , 0x01 , 0x01 , 0x01 , 0x01,
			0xC0 , 0x00 , 0x80 , 0x9D , 0x01 , 0x01 , 0x01 , 0x01,
			0x01 , 0x01 , 0x01 , 0x01 , 0x00 , 0x28 , 0x30 , 0x00,
			0x00 , 0x28 , 0x80 , 0xA4 , 0x00 , 0x00 , 0x80 , 0x80,
			0x80 , 0x13 , 0xDA , 0x4B , 0x28 , 0xA3 , 0x9F , 0x25,
			0xA3 , 0x9F , 0x25 , 0x00 , 0x00 , 0xFF , 0x01 , 0x44,
			0xC0 , 0x00 , 0x18 , 0x15 , 0x4B , 0x00 , 0x46 , 0x00,
			0x02, 0x00, 0x01, 0x00, 0x80, 0x84, 0x96, 0x60,
			0x7D, 0x22, 0xd4, 0x27, 0x00, 0x10, 0x7e, 0x03,
			0x58, 0x4b, 0xE0, 0xa6, 0x92, 0x54, 0x0e, 0x88,
			0x0c, 0x0A, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00,
			0x00, 0x80, 0x20, 0x5A, 0x00, 0x24, 0x00, 0x00,
			0x00 , 0x00 , 0x01 , 0x9C , 0x80 , 0xC0 , 0xC0 , 0x19,
			0x00 , 0x00 , 0x00 , 0x00 , 0x40 , 0x0F , 0xFC , 0x20,
			0xD0 , 0x6F , 0x0F , 0x00 , 0x00 , 0x0C , 0xF3 , 0x09,
			0xBD , 0x66 , 0xB5 , 0x90 , 0xB2 , 0x7D , 0x00 , 0x00
		}
		};

		while(n < (sizeof(dwa[0])/sizeof(DWORD))) *pdw++=dwa[bAvPack][n++];

		for(n=0;n1<(sizeof(baCrtc[0]));n++) {
			if((n!=0x11) && (n!=0x1f)) {
				*((volatile BYTE *)0xfd6013d4)=(BYTE)n;
				*((volatile BYTE *)0xfd6013d5)=baCrtc[bAvPack][n1++];
			}
		}


		for(n=0;n<sizeof(baConexant[0]);n++) {
			if(n!=(0xb8>>1)) {
				I2CTransmitWord(0x45, (n<<9)|baConexant[bAvPack][n]);
				WATCHDOG;
			}
		}
	}

//		memset((BYTE *)0x04000000-(640*480*4), 0xff000020, 640*480*4);

	voutl(0xfd001804, vinl(0xfd001804)|4);  // from kernel sub_0_80045C2A
	voutl(0xFD600140, 0);
	voutl(0xFD609140, 0);

	voutl(0xFD680600, 0);  // without this, blue horrors
	(*(volatile unsigned int*)0xFD600800)= (60 * 1024 * 1024);

	if(bAvPack!=7) {
		VIDEO_HEIGHT=480;
		VIDEO_MARGINX=0;
		VIDEO_MARGINY=0;
	} else { // composite+1 == 576 line request
		VIDEO_HEIGHT=576;
		VIDEO_MARGINX=40; // pixels
		VIDEO_MARGINY=40; // lines
	}

	switch(bAvPack) {  // radically changes colours if enabled on composite
		case 0:
			{
					// this might set up RGB out?
				voutl(0xFD680880, 0x21121111);
				voutl(0xFD609140, 0);
				voutl(0xFD682600, 0x100030);
				voutl(0xFD682630, 0);
				voutl(0xFD682634, 0);
				voutl(0xFD682638, 0);
				voutl(0xFD68263c, 0);
			}
			break;
		case 6:
			{
				voutl(0xFD680880, 0x21101100);
				voutl(0xFD682600,0 /* 0x100030 */);
/* rjs */
				voutl(0xFD682630, 2);
				voutl(0xFD682634, 0);
				voutl(0xFD682638, 0);
				voutl(0xFD68263c, 0);

				voutl(0xFD680324, 0x8b323bd7);
				voutl(0xFD680328, 0x66913ddf);
				voutl(0xFD68032c, 0x82afff2e);
				voutl(0xFD680330, 0xff4f218f);
				voutl(0xFD680504, 0x7702);
				voutl(0xFD680508, 0x3c20d);
				voutl(0xFD680518, 0x10101);
				voutl(0xFD680520, 0x3c20d);
				voutl(0xFD680544, 0x7702);
				voutl(0xFD680548, 0x3c20d);
				voutl(0xFD680558, 0x20202);
				voutl(0xFD680560, 0x3c20d);
/* end rjs */
			}
			break;
		case 7: // composite+1==576
			{
				voutl(0xFD680880, 0x21101100);
				voutl(0xFD682600,0 /* 0x100030 */);
				voutl(0xFD682630, 2);
				voutl(0xFD682634, 0);
				voutl(0xFD682638, 0);
				voutl(0xFD68263c, 0);

				voutl(0xFD680324, 0x388cd7be);
				voutl(0xFD680328, 0xfbdbebbc);
				voutl(0xFD68032c, 0xfddffffb);
				voutl(0xFD680330, 0xfffdffff);
				voutl(0xFD680504, 0x7702);
				voutl(0xFD680508, 0x3c20d);
				voutl(0xFD680518, 0x50505);
				voutl(0xFD680520, 0x3c20d);
				voutl(0xFD680544, 0x7702);
				voutl(0xFD680548, 0x3c20d);
				voutl(0xFD680558, 0x60606);
				voutl(0xFD680560, 0x3c20d);
			}
			break;
		case 8:
			{
				voutl(0xFD680880, 0x21101100);
				voutl(0xFD682600,0 /* 0x100030 */);
				voutl(0xFD682630, 2);
				voutl(0xFD682634, 0);
				voutl(0xFD682638, 0);
				voutl(0xFD68263c, 0);

				voutl(0xFD680324, 0x8b323bd7);
				voutl(0xFD680328, 0x66913ddf);
				voutl(0xFD68032c, 0x82afff2e);
				voutl(0xFD680330, 0xff4f218f);
				voutl(0xFD680504, 0x7702);
				voutl(0xFD680508, 0x3c20d);
				voutl(0xFD680518, 0x10101);
				voutl(0xFD680520, 0x3c20d);
				voutl(0xFD680544, 0x7702);
				voutl(0xFD680548, 0x3c20d);
				voutl(0xFD680558, 0x20202);
				voutl(0xFD680560, 0x3c20d);
			}
			break;
	}

#ifndef XBE
	voutl(0xfd600800, 0x83c00000);   // new guy, move the video out of the way

			// enable VSYNC interrupt action

	*((volatile DWORD *)0xfd600140)=0x1;  // enable VSYNC interrupts
	*((volatile DWORD *)0xfd600100)=0x1;  // clear VSYNC int
	*((volatile DWORD *)0xfd608000)=0x3c00000;  //
	*((volatile DWORD *)0xfd600140)=1;  // enable VSYNC int
	*((volatile DWORD *)0xfd000140)=0x1;  // enable VSYNC interrupts
	*((volatile DWORD *)0xfd000100)=0x1;  // clear VSYNC int
	*((volatile DWORD *)0xfd008000)=0x3c00000;  //
	*((volatile DWORD *)0xfd000140)=1;  // enable VSYNC int

//	BootVideoDelay();
	I2CTransmitWord(0x45, 0x6cc6);
#endif
	}
#ifndef XBE
	__asm__ __volatile__ ( "sti" );
#endif



	TRACE;
	return bAvPack;

}

void BootVideoEnableOutput(BYTE bAvPack)
{
	IoOutputByte(0x80d3, 5);  // some kind of MCPX thing REQUIRED
	IoOutputByte(0x80d6, 5);  // some kind of MCPX thing seen in kernel, set to 4 or 5
	IoOutputByte(0x80d8, 4);  // some kind of MCPX thing seen in kernel, set to 4
	IoOutputByte(0x80d3, 4);  // some kind of MCPX thing REQUIRED
	IoOutputByte(0x80d3, 4);  // some kind of MCPX thing REQUIRED

	vgaout(0xfd0C03C4, 1, 1); // screen on REQUIRED
	vgaout(0xfd0C03C4, 1, 1); // screen on REQUIRED
	voutw(0xfd6013c0, 1|(0x20 <<8));  // kernel: video on REQUIRED
//	voutb(0xfd6013c0, 0x01);
//	voutb(0xfd6013c0, 0x01);
	voutb(0xfd6013c0, 0x01);

	voutb(0xfd0C03C2, 0xe3);
	vgaout(0xfd6013D4, 0x11, 0x20);

		// enable VSYNC interrupt action

#ifndef XBE
	*((volatile DWORD *)0xfd600140)=0x1;  // enable VSYNC interrupts
	*((volatile DWORD *)0xfd600100)=0x1;  // clear VSYNC int
	*((volatile DWORD *)0xfd608000)=0x3c00000;  //
	*((volatile DWORD *)0xfd600140)=1;  // enable VSYNC int
	*((volatile DWORD *)0xfd000140)=0x1;  // enable VSYNC interrupts
	*((volatile DWORD *)0xfd000100)=0x1;  // clear VSYNC int
	*((volatile DWORD *)0xfd008000)=0x3c00000;  //
	*((volatile DWORD *)0xfd000140)=1;  // enable VSYNC int
#endif

}


